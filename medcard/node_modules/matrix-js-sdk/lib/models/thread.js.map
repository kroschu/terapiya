{"version":3,"file":"thread.js","names":["ThreadEvent","Thread","ReadReceipt","constructor","id","rootEvent","opts","hasServerSideSupport","event","redaction","isRelation","THREAD_RELATION_TYPE","name","room","eventShouldLiveIn","threadId","getId","status","replyCount","emit","Update","threadRootId","events","timelineSet","getLiveTimeline","getEvents","reverse","lastEvent","find","e","isRedacted","isThreadReply","localTimestamp","NewReply","Error","client","EventTimelineSet","timelineSupport","pendingEvents","reEmitter","TypedReEmitter","reEmit","RoomEvent","Timeline","TimelineReset","on","MatrixEventEvent","BeforeRedaction","onBeforeRedaction","Redaction","onRedaction","LocalEchoUpdated","onEcho","initialEvents","addEvents","initialiseThread","setThread","fetchRootEvent","findEventById","eventData","fetchRoomEvent","roomId","mapper","getEventMapper","logger","error","setServerSideSupport","useStable","FILTER_RELATED_BY_SENDERS","setPreferUnstable","FILTER_RELATED_BY_REL_TYPES","roomState","getState","EventTimeline","FORWARDS","addEventToTimeline","toStartOfTimeline","liveTimeline","fromCache","forEach","ev","addEvent","_currentUserParticipated","getSender","getUserId","decryptEventIfNeeded","initialEventsFetched","lastReply","fetchEditsWhereNeeded","RelationType","Annotation","Replace","relations","aggregateParentEvent","aggregateChildEvent","getRootEventBundledRelationship","getServerAggregatedRelation","bundledRelationship","count","current_user_participated","MatrixEvent","room_id","getRoomId","latest_event","setEventMetadata","Promise","all","filter","isEncrypted","map","getType","limit","then","length","makeReplaced","catch","fetchInitialEvents","fetchEvents","eventId","matches","i","replyToEvent","has","hasCurrentUserParticipated","direction","Direction","Backward","originalEvent","prevBatch","nextBatch","to","prependEvents","addEventsToTimeline","getUnfilteredTimelineSet","timeline","addReceipt","synthetic","ServerControlledNamespacedValue","ThreadFilterType"],"sources":["../../src/models/thread.ts"],"sourcesContent":["/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { Optional } from \"matrix-events-sdk\";\n\nimport { MatrixClient, MatrixEventEvent, RelationType, RoomEvent } from \"../matrix\";\nimport { TypedReEmitter } from \"../ReEmitter\";\nimport { IRelationsRequestOpts } from \"../@types/requests\";\nimport { IThreadBundledRelationship, MatrixEvent } from \"./event\";\nimport { Direction, EventTimeline } from \"./event-timeline\";\nimport { EventTimelineSet, EventTimelineSetHandlerMap } from './event-timeline-set';\nimport { Room } from './room';\nimport { RoomState } from \"./room-state\";\nimport { ServerControlledNamespacedValue } from \"../NamespacedValue\";\nimport { logger } from \"../logger\";\nimport { ReadReceipt } from \"./read-receipt\";\n\nexport enum ThreadEvent {\n    New = \"Thread.new\",\n    Update = \"Thread.update\",\n    NewReply = \"Thread.newReply\",\n    ViewThread = \"Thread.viewThread\",\n}\n\ntype EmittedEvents = Exclude<ThreadEvent, ThreadEvent.New>\n    | RoomEvent.Timeline\n    | RoomEvent.TimelineReset;\n\nexport type EventHandlerMap = {\n    [ThreadEvent.Update]: (thread: Thread) => void;\n    [ThreadEvent.NewReply]: (thread: Thread, event: MatrixEvent) => void;\n    [ThreadEvent.ViewThread]: () => void;\n} & EventTimelineSetHandlerMap;\n\ninterface IThreadOpts {\n    initialEvents?: MatrixEvent[];\n    room: Room;\n    client: MatrixClient;\n}\n\n/**\n * @experimental\n */\nexport class Thread extends ReadReceipt<EmittedEvents, EventHandlerMap> {\n    public static hasServerSideSupport: boolean;\n\n    /**\n     * A reference to all the events ID at the bottom of the threads\n     */\n    public readonly timelineSet: EventTimelineSet;\n\n    private _currentUserParticipated = false;\n\n    private reEmitter: TypedReEmitter<EmittedEvents, EventHandlerMap>;\n\n    private lastEvent: MatrixEvent;\n    private replyCount = 0;\n\n    public readonly room: Room;\n    public readonly client: MatrixClient;\n\n    public initialEventsFetched = !Thread.hasServerSideSupport;\n\n    constructor(\n        public readonly id: string,\n        public rootEvent: MatrixEvent | undefined,\n        opts: IThreadOpts,\n    ) {\n        super();\n\n        if (!opts?.room) {\n            // Logging/debugging for https://github.com/vector-im/element-web/issues/22141\n            // Hope is that we end up with a more obvious stack trace.\n            throw new Error(\"element-web#22141: A thread requires a room in order to function\");\n        }\n\n        this.room = opts.room;\n        this.client = opts.client;\n        this.timelineSet = new EventTimelineSet(this.room, {\n            timelineSupport: true,\n            pendingEvents: true,\n        }, this.client, this);\n        this.reEmitter = new TypedReEmitter(this);\n\n        this.reEmitter.reEmit(this.timelineSet, [\n            RoomEvent.Timeline,\n            RoomEvent.TimelineReset,\n        ]);\n\n        this.room.on(MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction);\n        this.room.on(RoomEvent.Redaction, this.onRedaction);\n        this.room.on(RoomEvent.LocalEchoUpdated, this.onEcho);\n        this.timelineSet.on(RoomEvent.Timeline, this.onEcho);\n\n        if (opts.initialEvents) {\n            this.addEvents(opts.initialEvents, false);\n        }\n        // even if this thread is thought to be originating from this client, we initialise it as we may be in a\n        // gappy sync and a thread around this event may already exist.\n        this.initialiseThread();\n\n        this.rootEvent?.setThread(this);\n    }\n\n    private async fetchRootEvent(): Promise<void> {\n        this.rootEvent = this.room.findEventById(this.id);\n        // If the rootEvent does not exist in the local stores, then fetch it from the server.\n        try {\n            const eventData = await this.client.fetchRoomEvent(this.roomId, this.id);\n            const mapper = this.client.getEventMapper();\n            this.rootEvent = mapper(eventData); // will merge with existing event object if such is known\n        } catch (e) {\n            logger.error(\"Failed to fetch thread root to construct thread with\", e);\n        }\n\n        // The root event might be not be visible to the person requesting it.\n        // If it wasn't fetched successfully the thread will work in \"limited\" mode and won't\n        // benefit from all the APIs a homeserver can provide to enhance the thread experience\n        this.rootEvent?.setThread(this);\n\n        this.emit(ThreadEvent.Update, this);\n    }\n\n    public static setServerSideSupport(hasServerSideSupport: boolean, useStable: boolean): void {\n        Thread.hasServerSideSupport = hasServerSideSupport;\n        if (!useStable) {\n            FILTER_RELATED_BY_SENDERS.setPreferUnstable(true);\n            FILTER_RELATED_BY_REL_TYPES.setPreferUnstable(true);\n            THREAD_RELATION_TYPE.setPreferUnstable(true);\n        }\n    }\n\n    private onBeforeRedaction = (event: MatrixEvent, redaction: MatrixEvent) => {\n        if (event?.isRelation(THREAD_RELATION_TYPE.name) &&\n            this.room.eventShouldLiveIn(event).threadId === this.id &&\n            event.getId() !== this.id && // the root event isn't counted in the length so ignore this redaction\n            !redaction.status // only respect it when it succeeds\n        ) {\n            this.replyCount--;\n            this.emit(ThreadEvent.Update, this);\n        }\n    };\n\n    private onRedaction = (event: MatrixEvent) => {\n        if (event.threadRootId !== this.id) return; // ignore redactions for other timelines\n        const events = [...this.timelineSet.getLiveTimeline().getEvents()].reverse();\n        this.lastEvent = events.find(e => (\n            !e.isRedacted() &&\n            e.isRelation(THREAD_RELATION_TYPE.name)\n        )) ?? this.rootEvent;\n        this.emit(ThreadEvent.Update, this);\n    };\n\n    private onEcho = (event: MatrixEvent) => {\n        if (event.threadRootId !== this.id) return; // ignore echoes for other timelines\n        if (this.lastEvent === event) return;\n        if (!event.isRelation(THREAD_RELATION_TYPE.name)) return;\n\n        // There is a risk that the `localTimestamp` approximation will not be accurate\n        // when threads are used over federation. That could result in the reply\n        // count value drifting away from the value returned by the server\n        const isThreadReply = event.isRelation(THREAD_RELATION_TYPE.name);\n        if (!this.lastEvent || this.lastEvent.isRedacted() || (isThreadReply\n            && (event.getId() !== this.lastEvent.getId())\n            && (event.localTimestamp > this.lastEvent.localTimestamp))\n        ) {\n            this.lastEvent = event;\n            if (this.lastEvent.getId() !== this.id) {\n                // This counting only works when server side support is enabled as we started the counting\n                // from the value returned within the bundled relationship\n                if (Thread.hasServerSideSupport) {\n                    this.replyCount++;\n                }\n\n                this.emit(ThreadEvent.NewReply, this, event);\n            }\n        }\n\n        this.emit(ThreadEvent.Update, this);\n    };\n\n    public get roomState(): RoomState {\n        return this.room.getLiveTimeline().getState(EventTimeline.FORWARDS);\n    }\n\n    private addEventToTimeline(event: MatrixEvent, toStartOfTimeline: boolean): void {\n        if (!this.findEventById(event.getId())) {\n            this.timelineSet.addEventToTimeline(\n                event,\n                this.liveTimeline,\n                {\n                    toStartOfTimeline,\n                    fromCache: false,\n                    roomState: this.roomState,\n                },\n            );\n        }\n    }\n\n    public addEvents(events: MatrixEvent[], toStartOfTimeline: boolean): void {\n        events.forEach(ev => this.addEvent(ev, toStartOfTimeline, false));\n        this.emit(ThreadEvent.Update, this);\n    }\n\n    /**\n     * Add an event to the thread and updates\n     * the tail/root references if needed\n     * Will fire \"Thread.update\"\n     * @param event The event to add\n     * @param {boolean} toStartOfTimeline whether the event is being added\n     * to the start (and not the end) of the timeline.\n     * @param {boolean} emit whether to emit the Update event if the thread was updated or not.\n     */\n    public addEvent(event: MatrixEvent, toStartOfTimeline: boolean, emit = true): void {\n        event.setThread(this);\n\n        if (!this._currentUserParticipated && event.getSender() === this.client.getUserId()) {\n            this._currentUserParticipated = true;\n        }\n\n        // Add all incoming events to the thread's timeline set when there's  no server support\n        if (!Thread.hasServerSideSupport) {\n            // all the relevant membership info to hydrate events with a sender\n            // is held in the main room timeline\n            // We want to fetch the room state from there and pass it down to this thread\n            // timeline set to let it reconcile an event with its relevant RoomMember\n            this.addEventToTimeline(event, toStartOfTimeline);\n\n            this.client.decryptEventIfNeeded(event, {});\n        } else if (!toStartOfTimeline &&\n            this.initialEventsFetched &&\n            event.localTimestamp > this.lastReply()?.localTimestamp\n        ) {\n            this.fetchEditsWhereNeeded(event);\n            this.addEventToTimeline(event, false);\n        } else if (event.isRelation(RelationType.Annotation) || event.isRelation(RelationType.Replace)) {\n            // Apply annotations and replace relations to the relations of the timeline only\n            this.timelineSet.relations.aggregateParentEvent(event);\n            this.timelineSet.relations.aggregateChildEvent(event, this.timelineSet);\n            return;\n        }\n\n        // If no thread support exists we want to count all thread relation\n        // added as a reply. We can't rely on the bundled relationships count\n        if ((!Thread.hasServerSideSupport || !this.rootEvent) && event.isRelation(THREAD_RELATION_TYPE.name)) {\n            this.replyCount++;\n        }\n\n        if (emit) {\n            this.emit(ThreadEvent.Update, this);\n        }\n    }\n\n    private getRootEventBundledRelationship(rootEvent = this.rootEvent): IThreadBundledRelationship {\n        return rootEvent?.getServerAggregatedRelation<IThreadBundledRelationship>(THREAD_RELATION_TYPE.name);\n    }\n\n    private async initialiseThread(): Promise<void> {\n        let bundledRelationship = this.getRootEventBundledRelationship();\n        if (Thread.hasServerSideSupport && !bundledRelationship) {\n            await this.fetchRootEvent();\n            bundledRelationship = this.getRootEventBundledRelationship();\n        }\n\n        if (Thread.hasServerSideSupport && bundledRelationship) {\n            this.replyCount = bundledRelationship.count;\n            this._currentUserParticipated = bundledRelationship.current_user_participated;\n\n            const event = new MatrixEvent({\n                room_id: this.rootEvent.getRoomId(),\n                ...bundledRelationship.latest_event,\n            });\n            this.setEventMetadata(event);\n            event.setThread(this);\n            this.lastEvent = event;\n\n            this.fetchEditsWhereNeeded(event);\n        }\n\n        this.emit(ThreadEvent.Update, this);\n    }\n\n    // XXX: Workaround for https://github.com/matrix-org/matrix-spec-proposals/pull/2676/files#r827240084\n    private async fetchEditsWhereNeeded(...events: MatrixEvent[]): Promise<unknown> {\n        return Promise.all(events.filter(e => e.isEncrypted()).map((event: MatrixEvent) => {\n            if (event.isRelation()) return; // skip - relations don't get edits\n            return this.client.relations(this.roomId, event.getId(), RelationType.Replace, event.getType(), {\n                limit: 1,\n            }).then(relations => {\n                if (relations.events.length) {\n                    event.makeReplaced(relations.events[0]);\n                }\n            }).catch(e => {\n                logger.error(\"Failed to load edits for encrypted thread event\", e);\n            });\n        }));\n    }\n\n    public async fetchInitialEvents(): Promise<void> {\n        if (this.initialEventsFetched) return;\n        await this.fetchEvents();\n        this.initialEventsFetched = true;\n    }\n\n    private setEventMetadata(event: MatrixEvent): void {\n        EventTimeline.setEventMetadata(event, this.roomState, false);\n        event.setThread(this);\n    }\n\n    /**\n     * Finds an event by ID in the current thread\n     */\n    public findEventById(eventId: string) {\n        // Check the lastEvent as it may have been created based on a bundled relationship and not in a timeline\n        if (this.lastEvent?.getId() === eventId) {\n            return this.lastEvent;\n        }\n\n        return this.timelineSet.findEventById(eventId);\n    }\n\n    /**\n     * Return last reply to the thread, if known.\n     */\n    public lastReply(matches: (ev: MatrixEvent) => boolean = () => true): MatrixEvent | null {\n        for (let i = this.events.length - 1; i >= 0; i--) {\n            const event = this.events[i];\n            if (matches(event)) {\n                return event;\n            }\n        }\n        return null;\n    }\n\n    public get roomId(): string {\n        return this.room.roomId;\n    }\n\n    /**\n     * The number of messages in the thread\n     * Only count rel_type=m.thread as we want to\n     * exclude annotations from that number\n     */\n    public get length(): number {\n        return this.replyCount;\n    }\n\n    /**\n     * A getter for the last event added to the thread, if known.\n     */\n    public get replyToEvent(): Optional<MatrixEvent> {\n        return this.lastEvent ?? this.lastReply();\n    }\n\n    public get events(): MatrixEvent[] {\n        return this.liveTimeline.getEvents();\n    }\n\n    public has(eventId: string): boolean {\n        return this.timelineSet.findEventById(eventId) instanceof MatrixEvent;\n    }\n\n    public get hasCurrentUserParticipated(): boolean {\n        return this._currentUserParticipated;\n    }\n\n    public get liveTimeline(): EventTimeline {\n        return this.timelineSet.getLiveTimeline();\n    }\n\n    public async fetchEvents(opts: IRelationsRequestOpts = { limit: 20, direction: Direction.Backward }): Promise<{\n        originalEvent: MatrixEvent;\n        events: MatrixEvent[];\n        nextBatch?: string | null;\n        prevBatch?: string;\n    }> {\n        let {\n            originalEvent,\n            events,\n            prevBatch,\n            nextBatch,\n        } = await this.client.relations(\n            this.room.roomId,\n            this.id,\n            THREAD_RELATION_TYPE.name,\n            null,\n            opts,\n        );\n\n        // When there's no nextBatch returned with a `from` request we have reached\n        // the end of the thread, and therefore want to return an empty one\n        if (!opts.to && !nextBatch) {\n            events = [...events, originalEvent];\n        }\n\n        await this.fetchEditsWhereNeeded(...events);\n\n        await Promise.all(events.map(event => {\n            this.setEventMetadata(event);\n            return this.client.decryptEventIfNeeded(event);\n        }));\n\n        const prependEvents = (opts.direction ?? Direction.Backward) === Direction.Backward;\n\n        this.timelineSet.addEventsToTimeline(\n            events,\n            prependEvents,\n            this.liveTimeline,\n            prependEvents ? nextBatch : prevBatch,\n        );\n\n        return {\n            originalEvent,\n            events,\n            prevBatch,\n            nextBatch,\n        };\n    }\n\n    public getUnfilteredTimelineSet(): EventTimelineSet {\n        return this.timelineSet;\n    }\n\n    public get timeline(): MatrixEvent[] {\n        return this.events;\n    }\n\n    public addReceipt(event: MatrixEvent, synthetic: boolean): void {\n        throw new Error(\"Unsupported function on the thread model\");\n    }\n}\n\nexport const FILTER_RELATED_BY_SENDERS = new ServerControlledNamespacedValue(\n    \"related_by_senders\",\n    \"io.element.relation_senders\",\n);\nexport const FILTER_RELATED_BY_REL_TYPES = new ServerControlledNamespacedValue(\n    \"related_by_rel_types\",\n    \"io.element.relation_types\",\n);\nexport const THREAD_RELATION_TYPE = new ServerControlledNamespacedValue(\n    \"m.thread\",\n    \"io.element.thread\",\n);\n\nexport enum ThreadFilterType {\n    \"My\",\n    \"All\"\n}\n"],"mappings":"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"}