{"version":3,"file":"event-timeline-set.js","names":["DEBUG","debuglog","logger","log","bind","DuplicateStrategy","EventTimelineSet","TypedEventEmitter","constructor","room","opts","client","thread","Map","timelineSupport","Boolean","liveTimeline","EventTimeline","displayPendingEvents","pendingEvents","timelines","_eventIdToTimeline","filter","relations","RelationsContainer","getTimelines","getFilter","setFilter","getPendingEvents","getLiveTimeline","setLiveTimeline","timeline","eventIdToTimeline","eventId","get","replaceEventId","oldEventId","newEventId","existingTimeline","delete","set","resetLiveTimeline","backPaginationToken","forwardPaginationToken","resetAllTimelines","oldTimeline","newTimeline","forkLive","FORWARDS","fork","push","setPaginationToken","BACKWARDS","emit","RoomEvent","TimelineReset","getTimelineForEvent","res","undefined","findEventById","tl","getEvents","find","ev","getId","addTimeline","Error","addEventsToTimeline","events","toStartOfTimeline","paginationToken","filterRoomTimeline","length","direction","inverseDirection","didUpdate","lastEventWasNew","i","event","addEventToTimeline","neighbour","getNeighbouringTimeline","info","existingIsLive","timelineIsLive","backwardsIsLive","forwardsIsLive","warn","setNeighbouringTimeline","addLiveEvent","duplicateStrategyOrOpts","fromCache","roomState","duplicateStrategy","Ignore","timelineWasEmpty","Replace","tlEvents","j","getState","setEventMetadata","toStartOfTimelineOrOpts","addEvent","aggregateParentEvent","aggregateChildEvent","data","liveEvent","Timeline","handleRemoteEcho","localEvent","removeEvent","removed","compareEventOrdering","eventId1","eventId2","timeline1","timeline2","idx1","idx2","idx","evId","canContain","threadId","shouldLiveInRoom","eventShouldLiveIn","id"],"sources":["../../src/models/event-timeline-set.ts"],"sourcesContent":["/*\nCopyright 2016 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @module models/event-timeline-set\n */\n\nimport { EventTimeline, IAddEventOptions } from \"./event-timeline\";\nimport { MatrixEvent } from \"./event\";\nimport { logger } from '../logger';\nimport { Room, RoomEvent } from \"./room\";\nimport { Filter } from \"../filter\";\nimport { RoomState } from \"./room-state\";\nimport { TypedEventEmitter } from \"./typed-event-emitter\";\nimport { RelationsContainer } from \"./relations-container\";\nimport { MatrixClient } from \"../client\";\nimport { Thread } from \"./thread\";\n\nconst DEBUG = true;\n\nlet debuglog: (...args: any[]) => void;\nif (DEBUG) {\n    // using bind means that we get to keep useful line numbers in the console\n    debuglog = logger.log.bind(logger);\n} else {\n    debuglog = function() {};\n}\n\ninterface IOpts {\n    timelineSupport?: boolean;\n    filter?: Filter;\n    pendingEvents?: boolean;\n}\n\nexport enum DuplicateStrategy {\n    Ignore = \"ignore\",\n    Replace = \"replace\",\n}\n\nexport interface IRoomTimelineData {\n    timeline: EventTimeline;\n    liveEvent?: boolean;\n}\n\nexport interface IAddEventToTimelineOptions\n    extends Pick<IAddEventOptions, 'toStartOfTimeline' | 'roomState' | 'timelineWasEmpty'> {\n    /** Whether the sync response came from cache */\n    fromCache?: boolean;\n}\n\nexport interface IAddLiveEventOptions\n    extends Pick<IAddEventToTimelineOptions, 'fromCache' | 'roomState' | 'timelineWasEmpty'> {\n    /** Applies to events in the timeline only. If this is 'replace' then if a\n     * duplicate is encountered, the event passed to this function will replace\n     * the existing event in the timeline. If this is not specified, or is\n     * 'ignore', then the event passed to this function will be ignored\n     * entirely, preserving the existing event in the timeline. Events are\n     * identical based on their event ID <b>only</b>. */\n    duplicateStrategy?: DuplicateStrategy;\n}\n\ntype EmittedEvents = RoomEvent.Timeline | RoomEvent.TimelineReset;\n\nexport type EventTimelineSetHandlerMap = {\n    [RoomEvent.Timeline]:\n        (event: MatrixEvent, room: Room, toStartOfTimeline: boolean, removed: boolean, data: IRoomTimelineData) => void;\n    [RoomEvent.TimelineReset]: (room: Room, eventTimelineSet: EventTimelineSet, resetAllTimelines: boolean) => void;\n};\n\nexport class EventTimelineSet extends TypedEventEmitter<EmittedEvents, EventTimelineSetHandlerMap> {\n    public readonly relations?: RelationsContainer;\n    private readonly timelineSupport: boolean;\n    private readonly displayPendingEvents: boolean;\n    private liveTimeline: EventTimeline;\n    private timelines: EventTimeline[];\n    private _eventIdToTimeline = new Map<string, EventTimeline>();\n    private filter?: Filter;\n\n    /**\n     * Construct a set of EventTimeline objects, typically on behalf of a given\n     * room.  A room may have multiple EventTimelineSets for different levels\n     * of filtering.  The global notification list is also an EventTimelineSet, but\n     * lacks a room.\n     *\n     * <p>This is an ordered sequence of timelines, which may or may not\n     * be continuous. Each timeline lists a series of events, as well as tracking\n     * the room state at the start and the end of the timeline (if appropriate).\n     * It also tracks forward and backward pagination tokens, as well as containing\n     * links to the next timeline in the sequence.\n     *\n     * <p>There is one special timeline - the 'live' timeline, which represents the\n     * timeline to which events are being added in real-time as they are received\n     * from the /sync API. Note that you should not retain references to this\n     * timeline - even if it is the current timeline right now, it may not remain\n     * so if the server gives us a timeline gap in /sync.\n     *\n     * <p>In order that we can find events from their ids later, we also maintain a\n     * map from event_id to timeline and index.\n     *\n     * @constructor\n     * @param {Room=} room\n     * Room for this timelineSet. May be null for non-room cases, such as the\n     * notification timeline.\n     * @param {Object} opts Options inherited from Room.\n     *\n     * @param {boolean} [opts.timelineSupport = false]\n     * Set to true to enable improved timeline support.\n     * @param {Object} [opts.filter = null]\n     * The filter object, if any, for this timelineSet.\n     * @param {MatrixClient=} client the Matrix client which owns this EventTimelineSet,\n     * can be omitted if room is specified.\n     * @param {Thread=} thread the thread to which this timeline set relates.\n     */\n    constructor(\n        public readonly room: Room | undefined,\n        opts: IOpts = {},\n        client?: MatrixClient,\n        public readonly thread?: Thread,\n    ) {\n        super();\n\n        this.timelineSupport = Boolean(opts.timelineSupport);\n        this.liveTimeline = new EventTimeline(this);\n        this.displayPendingEvents = opts.pendingEvents !== false;\n\n        // just a list - *not* ordered.\n        this.timelines = [this.liveTimeline];\n        this._eventIdToTimeline = new Map<string, EventTimeline>();\n\n        this.filter = opts.filter;\n\n        this.relations = this.room?.relations ?? new RelationsContainer(room?.client ?? client);\n    }\n\n    /**\n     * Get all the timelines in this set\n     * @return {module:models/event-timeline~EventTimeline[]} the timelines in this set\n     */\n    public getTimelines(): EventTimeline[] {\n        return this.timelines;\n    }\n\n    /**\n     * Get the filter object this timeline set is filtered on, if any\n     * @return {?Filter} the optional filter for this timelineSet\n     */\n    public getFilter(): Filter | undefined {\n        return this.filter;\n    }\n\n    /**\n     * Set the filter object this timeline set is filtered on\n     * (passed to the server when paginating via /messages).\n     * @param {Filter} filter the filter for this timelineSet\n     */\n    public setFilter(filter?: Filter): void {\n        this.filter = filter;\n    }\n\n    /**\n     * Get the list of pending sent events for this timelineSet's room, filtered\n     * by the timelineSet's filter if appropriate.\n     *\n     * @return {module:models/event.MatrixEvent[]} A list of the sent events\n     * waiting for remote echo.\n     *\n     * @throws If <code>opts.pendingEventOrdering</code> was not 'detached'\n     */\n    public getPendingEvents(): MatrixEvent[] {\n        if (!this.room || !this.displayPendingEvents) {\n            return [];\n        }\n\n        return this.room.getPendingEvents();\n    }\n    /**\n     * Get the live timeline for this room.\n     *\n     * @return {module:models/event-timeline~EventTimeline} live timeline\n     */\n    public getLiveTimeline(): EventTimeline {\n        return this.liveTimeline;\n    }\n\n    /**\n     * Set the live timeline for this room.\n     *\n     * @return {module:models/event-timeline~EventTimeline} live timeline\n     */\n    public setLiveTimeline(timeline: EventTimeline): void {\n        this.liveTimeline = timeline;\n    }\n\n    /**\n     * Return the timeline (if any) this event is in.\n     * @param {String} eventId the eventId being sought\n     * @return {module:models/event-timeline~EventTimeline} timeline\n     */\n    public eventIdToTimeline(eventId: string): EventTimeline {\n        return this._eventIdToTimeline.get(eventId);\n    }\n\n    /**\n     * Track a new event as if it were in the same timeline as an old event,\n     * replacing it.\n     * @param {String} oldEventId  event ID of the original event\n     * @param {String} newEventId  event ID of the replacement event\n     */\n    public replaceEventId(oldEventId: string, newEventId: string): void {\n        const existingTimeline = this._eventIdToTimeline.get(oldEventId);\n        if (existingTimeline) {\n            this._eventIdToTimeline.delete(oldEventId);\n            this._eventIdToTimeline.set(newEventId, existingTimeline);\n        }\n    }\n\n    /**\n     * Reset the live timeline, and start a new one.\n     *\n     * <p>This is used when /sync returns a 'limited' timeline.\n     *\n     * @param {string=} backPaginationToken   token for back-paginating the new timeline\n     * @param {string=} forwardPaginationToken token for forward-paginating the old live timeline,\n     * if absent or null, all timelines are reset.\n     *\n     * @fires module:client~MatrixClient#event:\"Room.timelineReset\"\n     */\n    public resetLiveTimeline(backPaginationToken?: string, forwardPaginationToken?: string): void {\n        // Each EventTimeline has RoomState objects tracking the state at the start\n        // and end of that timeline. The copies at the end of the live timeline are\n        // special because they will have listeners attached to monitor changes to\n        // the current room state, so we move this RoomState from the end of the\n        // current live timeline to the end of the new one and, if necessary,\n        // replace it with a newly created one. We also make a copy for the start\n        // of the new timeline.\n\n        // if timeline support is disabled, forget about the old timelines\n        const resetAllTimelines = !this.timelineSupport || !forwardPaginationToken;\n\n        const oldTimeline = this.liveTimeline;\n        const newTimeline = resetAllTimelines ?\n            oldTimeline.forkLive(EventTimeline.FORWARDS) :\n            oldTimeline.fork(EventTimeline.FORWARDS);\n\n        if (resetAllTimelines) {\n            this.timelines = [newTimeline];\n            this._eventIdToTimeline = new Map<string, EventTimeline>();\n        } else {\n            this.timelines.push(newTimeline);\n        }\n\n        if (forwardPaginationToken) {\n            // Now set the forward pagination token on the old live timeline\n            // so it can be forward-paginated.\n            oldTimeline.setPaginationToken(\n                forwardPaginationToken, EventTimeline.FORWARDS,\n            );\n        }\n\n        // make sure we set the pagination token before firing timelineReset,\n        // otherwise clients which start back-paginating will fail, and then get\n        // stuck without realising that they *can* back-paginate.\n        newTimeline.setPaginationToken(backPaginationToken, EventTimeline.BACKWARDS);\n\n        // Now we can swap the live timeline to the new one.\n        this.liveTimeline = newTimeline;\n        this.emit(RoomEvent.TimelineReset, this.room, this, resetAllTimelines);\n    }\n\n    /**\n     * Get the timeline which contains the given event, if any\n     *\n     * @param {string} eventId  event ID to look for\n     * @return {?module:models/event-timeline~EventTimeline} timeline containing\n     * the given event, or null if unknown\n     */\n    public getTimelineForEvent(eventId: string | null): EventTimeline | null {\n        if (eventId === null) { return null; }\n        const res = this._eventIdToTimeline.get(eventId);\n        return (res === undefined) ? null : res;\n    }\n\n    /**\n     * Get an event which is stored in our timelines\n     *\n     * @param {string} eventId  event ID to look for\n     * @return {?module:models/event~MatrixEvent} the given event, or undefined if unknown\n     */\n    public findEventById(eventId: string): MatrixEvent | undefined {\n        const tl = this.getTimelineForEvent(eventId);\n        if (!tl) {\n            return undefined;\n        }\n        return tl.getEvents().find(function(ev) {\n            return ev.getId() == eventId;\n        });\n    }\n\n    /**\n     * Add a new timeline to this timeline list\n     *\n     * @return {module:models/event-timeline~EventTimeline} newly-created timeline\n     */\n    public addTimeline(): EventTimeline {\n        if (!this.timelineSupport) {\n            throw new Error(\"timeline support is disabled. Set the 'timelineSupport'\" +\n                \" parameter to true when creating MatrixClient to enable\" +\n                \" it.\");\n        }\n\n        const timeline = new EventTimeline(this);\n        this.timelines.push(timeline);\n        return timeline;\n    }\n\n    /**\n     * Add events to a timeline\n     *\n     * <p>Will fire \"Room.timeline\" for each event added.\n     *\n     * @param {MatrixEvent[]} events A list of events to add.\n     *\n     * @param {boolean} toStartOfTimeline   True to add these events to the start\n     * (oldest) instead of the end (newest) of the timeline. If true, the oldest\n     * event will be the <b>last</b> element of 'events'.\n     *\n     * @param {module:models/event-timeline~EventTimeline} timeline   timeline to\n     *    add events to.\n     *\n     * @param {string=} paginationToken   token for the next batch of events\n     *\n     * @fires module:client~MatrixClient#event:\"Room.timeline\"\n     *\n     */\n    public addEventsToTimeline(\n        events: MatrixEvent[],\n        toStartOfTimeline: boolean,\n        timeline: EventTimeline,\n        paginationToken: string,\n    ): void {\n        if (!timeline) {\n            throw new Error(\n                \"'timeline' not specified for EventTimelineSet.addEventsToTimeline\",\n            );\n        }\n\n        if (!toStartOfTimeline && timeline == this.liveTimeline) {\n            throw new Error(\n                \"EventTimelineSet.addEventsToTimeline cannot be used for adding events to \" +\n                \"the live timeline - use Room.addLiveEvents instead\",\n            );\n        }\n\n        if (this.filter) {\n            events = this.filter.filterRoomTimeline(events);\n            if (!events.length) {\n                return;\n            }\n        }\n\n        const direction = toStartOfTimeline ? EventTimeline.BACKWARDS :\n            EventTimeline.FORWARDS;\n        const inverseDirection = toStartOfTimeline ? EventTimeline.FORWARDS :\n            EventTimeline.BACKWARDS;\n\n        // Adding events to timelines can be quite complicated. The following\n        // illustrates some of the corner-cases.\n        //\n        // Let's say we start by knowing about four timelines. timeline3 and\n        // timeline4 are neighbours:\n        //\n        //    timeline1    timeline2    timeline3    timeline4\n        //      [M]          [P]          [S] <------> [T]\n        //\n        // Now we paginate timeline1, and get the following events from the server:\n        // [M, N, P, R, S, T, U].\n        //\n        // 1. First, we ignore event M, since we already know about it.\n        //\n        // 2. Next, we append N to timeline 1.\n        //\n        // 3. Next, we don't add event P, since we already know about it,\n        //    but we do link together the timelines. We now have:\n        //\n        //    timeline1    timeline2    timeline3    timeline4\n        //      [M, N] <---> [P]          [S] <------> [T]\n        //\n        // 4. Now we add event R to timeline2:\n        //\n        //    timeline1    timeline2    timeline3    timeline4\n        //      [M, N] <---> [P, R]       [S] <------> [T]\n        //\n        //    Note that we have switched the timeline we are working on from\n        //    timeline1 to timeline2.\n        //\n        // 5. We ignore event S, but again join the timelines:\n        //\n        //    timeline1    timeline2    timeline3    timeline4\n        //      [M, N] <---> [P, R] <---> [S] <------> [T]\n        //\n        // 6. We ignore event T, and the timelines are already joined, so there\n        //    is nothing to do.\n        //\n        // 7. Finally, we add event U to timeline4:\n        //\n        //    timeline1    timeline2    timeline3    timeline4\n        //      [M, N] <---> [P, R] <---> [S] <------> [T, U]\n        //\n        // The important thing to note in the above is what happened when we\n        // already knew about a given event:\n        //\n        //   - if it was appropriate, we joined up the timelines (steps 3, 5).\n        //   - in any case, we started adding further events to the timeline which\n        //       contained the event we knew about (steps 3, 5, 6).\n        //\n        //\n        // So much for adding events to the timeline. But what do we want to do\n        // with the pagination token?\n        //\n        // In the case above, we will be given a pagination token which tells us how to\n        // get events beyond 'U' - in this case, it makes sense to store this\n        // against timeline4. But what if timeline4 already had 'U' and beyond? in\n        // that case, our best bet is to throw away the pagination token we were\n        // given and stick with whatever token timeline4 had previously. In short,\n        // we want to only store the pagination token if the last event we receive\n        // is one we didn't previously know about.\n        //\n        // We make an exception for this if it turns out that we already knew about\n        // *all* of the events, and we weren't able to join up any timelines. When\n        // that happens, it means our existing pagination token is faulty, since it\n        // is only telling us what we already know. Rather than repeatedly\n        // paginating with the same token, we might as well use the new pagination\n        // token in the hope that we eventually work our way out of the mess.\n\n        let didUpdate = false;\n        let lastEventWasNew = false;\n        for (let i = 0; i < events.length; i++) {\n            const event = events[i];\n            const eventId = event.getId();\n\n            const existingTimeline = this._eventIdToTimeline.get(eventId);\n\n            if (!existingTimeline) {\n                // we don't know about this event yet. Just add it to the timeline.\n                this.addEventToTimeline(event, timeline, {\n                    toStartOfTimeline,\n                });\n                lastEventWasNew = true;\n                didUpdate = true;\n                continue;\n            }\n\n            lastEventWasNew = false;\n\n            if (existingTimeline == timeline) {\n                debuglog(\"Event \" + eventId + \" already in timeline \" + timeline);\n                continue;\n            }\n\n            const neighbour = timeline.getNeighbouringTimeline(direction);\n            if (neighbour) {\n                // this timeline already has a neighbour in the relevant direction;\n                // let's assume the timelines are already correctly linked up, and\n                // skip over to it.\n                //\n                // there's probably some edge-case here where we end up with an\n                // event which is in a timeline a way down the chain, and there is\n                // a break in the chain somewhere. But I can't really imagine how\n                // that would happen, so I'm going to ignore it for now.\n                //\n                if (existingTimeline == neighbour) {\n                    debuglog(\"Event \" + eventId + \" in neighbouring timeline - \" +\n                        \"switching to \" + existingTimeline);\n                } else {\n                    debuglog(\"Event \" + eventId + \" already in a different \" +\n                        \"timeline \" + existingTimeline);\n                }\n                timeline = existingTimeline;\n                continue;\n            }\n\n            // time to join the timelines.\n            logger.info(\"Already have timeline for \" + eventId +\n                \" - joining timeline \" + timeline + \" to \" +\n                existingTimeline);\n\n            // Variables to keep the line length limited below.\n            const existingIsLive = existingTimeline === this.liveTimeline;\n            const timelineIsLive = timeline === this.liveTimeline;\n\n            const backwardsIsLive = direction === EventTimeline.BACKWARDS && existingIsLive;\n            const forwardsIsLive = direction === EventTimeline.FORWARDS && timelineIsLive;\n\n            if (backwardsIsLive || forwardsIsLive) {\n                // The live timeline should never be spliced into a non-live position.\n                // We use independent logging to better discover the problem at a glance.\n                if (backwardsIsLive) {\n                    logger.warn(\n                        \"Refusing to set a preceding existingTimeLine on our \" +\n                        \"timeline as the existingTimeLine is live (\" + existingTimeline + \")\",\n                    );\n                }\n                if (forwardsIsLive) {\n                    logger.warn(\n                        \"Refusing to set our preceding timeline on a existingTimeLine \" +\n                        \"as our timeline is live (\" + timeline + \")\",\n                    );\n                }\n                continue; // abort splicing - try next event\n            }\n\n            timeline.setNeighbouringTimeline(existingTimeline, direction);\n            existingTimeline.setNeighbouringTimeline(timeline, inverseDirection);\n\n            timeline = existingTimeline;\n            didUpdate = true;\n        }\n\n        // see above - if the last event was new to us, or if we didn't find any\n        // new information, we update the pagination token for whatever\n        // timeline we ended up on.\n        if (lastEventWasNew || !didUpdate) {\n            if (direction === EventTimeline.FORWARDS && timeline === this.liveTimeline) {\n                logger.warn({ lastEventWasNew, didUpdate }); // for debugging\n                logger.warn(\n                    `Refusing to set forwards pagination token of live timeline ` +\n                    `${timeline} to ${paginationToken}`,\n                );\n                return;\n            }\n            timeline.setPaginationToken(paginationToken, direction);\n        }\n    }\n\n    /**\n     * Add an event to the end of this live timeline.\n     *\n     * @param {MatrixEvent} event Event to be added\n     * @param {IAddLiveEventOptions} options addLiveEvent options\n     */\n    public addLiveEvent(\n        event: MatrixEvent,\n        {\n            duplicateStrategy,\n            fromCache,\n            roomState,\n            timelineWasEmpty,\n        }: IAddLiveEventOptions,\n    ): void;\n    /**\n     * @deprecated In favor of the overload with `IAddLiveEventOptions`\n     */\n    public addLiveEvent(\n        event: MatrixEvent,\n        duplicateStrategy?: DuplicateStrategy,\n        fromCache?: boolean,\n        roomState?: RoomState,\n    ): void;\n    public addLiveEvent(\n        event: MatrixEvent,\n        duplicateStrategyOrOpts?: DuplicateStrategy | IAddLiveEventOptions,\n        fromCache = false,\n        roomState?: RoomState,\n    ): void {\n        let duplicateStrategy = duplicateStrategyOrOpts as DuplicateStrategy || DuplicateStrategy.Ignore;\n        let timelineWasEmpty: boolean;\n        if (typeof (duplicateStrategyOrOpts) === 'object') {\n            ({\n                duplicateStrategy = DuplicateStrategy.Ignore,\n                fromCache = false,\n                roomState,\n                timelineWasEmpty,\n            } = duplicateStrategyOrOpts);\n        } else if (duplicateStrategyOrOpts !== undefined) {\n            // Deprecation warning\n            // FIXME: Remove after 2023-06-01 (technical debt)\n            logger.warn(\n                'Overload deprecated: ' +\n                '`EventTimelineSet.addLiveEvent(event, duplicateStrategy?, fromCache?, roomState?)` ' +\n                'is deprecated in favor of the overload with ' +\n                '`EventTimelineSet.addLiveEvent(event, IAddLiveEventOptions)`',\n            );\n        }\n\n        if (this.filter) {\n            const events = this.filter.filterRoomTimeline([event]);\n            if (!events.length) {\n                return;\n            }\n        }\n\n        const timeline = this._eventIdToTimeline.get(event.getId());\n        if (timeline) {\n            if (duplicateStrategy === DuplicateStrategy.Replace) {\n                debuglog(\"EventTimelineSet.addLiveEvent: replacing duplicate event \" + event.getId());\n                const tlEvents = timeline.getEvents();\n                for (let j = 0; j < tlEvents.length; j++) {\n                    if (tlEvents[j].getId() === event.getId()) {\n                        // still need to set the right metadata on this event\n                        if (!roomState) {\n                            roomState = timeline.getState(EventTimeline.FORWARDS);\n                        }\n                        EventTimeline.setEventMetadata(\n                            event,\n                            roomState,\n                            false,\n                        );\n                        tlEvents[j] = event;\n\n                        // XXX: we need to fire an event when this happens.\n                        break;\n                    }\n                }\n            } else {\n                debuglog(\"EventTimelineSet.addLiveEvent: ignoring duplicate event \" + event.getId());\n            }\n            return;\n        }\n\n        this.addEventToTimeline(event, this.liveTimeline, {\n            toStartOfTimeline: false,\n            fromCache,\n            roomState,\n            timelineWasEmpty,\n        });\n    }\n\n    /**\n     * Add event to the given timeline, and emit Room.timeline. Assumes\n     * we have already checked we don't know about this event.\n     *\n     * Will fire \"Room.timeline\" for each event added.\n     *\n     * @param {MatrixEvent} event\n     * @param {EventTimeline} timeline\n     * @param {IAddEventToTimelineOptions} options addEventToTimeline options\n     *\n     * @fires module:client~MatrixClient#event:\"Room.timeline\"\n     */\n    public addEventToTimeline(\n        event: MatrixEvent,\n        timeline: EventTimeline,\n        {\n            toStartOfTimeline,\n            fromCache,\n            roomState,\n            timelineWasEmpty,\n        }: IAddEventToTimelineOptions,\n    ): void;\n    /**\n     * @deprecated In favor of the overload with `IAddEventToTimelineOptions`\n     */\n    public addEventToTimeline(\n        event: MatrixEvent,\n        timeline: EventTimeline,\n        toStartOfTimeline: boolean,\n        fromCache?: boolean,\n        roomState?: RoomState,\n    ): void;\n    public addEventToTimeline(\n        event: MatrixEvent,\n        timeline: EventTimeline,\n        toStartOfTimelineOrOpts: boolean | IAddEventToTimelineOptions,\n        fromCache = false,\n        roomState?: RoomState,\n    ): void {\n        let toStartOfTimeline = !!toStartOfTimelineOrOpts;\n        let timelineWasEmpty: boolean;\n        if (typeof (toStartOfTimelineOrOpts) === 'object') {\n            ({ toStartOfTimeline, fromCache = false, roomState, timelineWasEmpty } = toStartOfTimelineOrOpts);\n        } else if (toStartOfTimelineOrOpts !== undefined) {\n            // Deprecation warning\n            // FIXME: Remove after 2023-06-01 (technical debt)\n            logger.warn(\n                'Overload deprecated: ' +\n                '`EventTimelineSet.addEventToTimeline(event, timeline, toStartOfTimeline, fromCache?, roomState?)` ' +\n                'is deprecated in favor of the overload with ' +\n                '`EventTimelineSet.addEventToTimeline(event, timeline, IAddEventToTimelineOptions)`',\n            );\n        }\n\n        const eventId = event.getId();\n        timeline.addEvent(event, {\n            toStartOfTimeline,\n            roomState,\n            timelineWasEmpty,\n        });\n        this._eventIdToTimeline.set(eventId, timeline);\n\n        this.relations.aggregateParentEvent(event);\n        this.relations.aggregateChildEvent(event, this);\n\n        const data: IRoomTimelineData = {\n            timeline: timeline,\n            liveEvent: !toStartOfTimeline && timeline == this.liveTimeline && !fromCache,\n        };\n        this.emit(RoomEvent.Timeline, event, this.room, Boolean(toStartOfTimeline), false, data);\n    }\n\n    /**\n     * Replaces event with ID oldEventId with one with newEventId, if oldEventId is\n     * recognised.  Otherwise, add to the live timeline.  Used to handle remote echos.\n     *\n     * @param {MatrixEvent} localEvent     the new event to be added to the timeline\n     * @param {String} oldEventId          the ID of the original event\n     * @param {boolean} newEventId         the ID of the replacement event\n     *\n     * @fires module:client~MatrixClient#event:\"Room.timeline\"\n     */\n    public handleRemoteEcho(\n        localEvent: MatrixEvent,\n        oldEventId: string,\n        newEventId: string,\n    ): void {\n        // XXX: why don't we infer newEventId from localEvent?\n        const existingTimeline = this._eventIdToTimeline.get(oldEventId);\n        if (existingTimeline) {\n            this._eventIdToTimeline.delete(oldEventId);\n            this._eventIdToTimeline.set(newEventId, existingTimeline);\n        } else if (!this.filter || this.filter.filterRoomTimeline([localEvent]).length) {\n            this.addEventToTimeline(localEvent, this.liveTimeline, {\n                toStartOfTimeline: false,\n            });\n        }\n    }\n\n    /**\n     * Removes a single event from this room.\n     *\n     * @param {String} eventId  The id of the event to remove\n     *\n     * @return {?MatrixEvent} the removed event, or null if the event was not found\n     * in this room.\n     */\n    public removeEvent(eventId: string): MatrixEvent | null {\n        const timeline = this._eventIdToTimeline.get(eventId);\n        if (!timeline) {\n            return null;\n        }\n\n        const removed = timeline.removeEvent(eventId);\n        if (removed) {\n            this._eventIdToTimeline.delete(eventId);\n            const data = {\n                timeline: timeline,\n            };\n            this.emit(RoomEvent.Timeline, removed, this.room, undefined, true, data);\n        }\n        return removed;\n    }\n\n    /**\n     * Determine where two events appear in the timeline relative to one another\n     *\n     * @param {string} eventId1   The id of the first event\n     * @param {string} eventId2   The id of the second event\n\n     * @return {?number} a number less than zero if eventId1 precedes eventId2, and\n     *    greater than zero if eventId1 succeeds eventId2. zero if they are the\n     *    same event; null if we can't tell (either because we don't know about one\n     *    of the events, or because they are in separate timelines which don't join\n     *    up).\n     */\n    public compareEventOrdering(eventId1: string, eventId2: string): number | null {\n        if (eventId1 == eventId2) {\n            // optimise this case\n            return 0;\n        }\n\n        const timeline1 = this._eventIdToTimeline.get(eventId1);\n        const timeline2 = this._eventIdToTimeline.get(eventId2);\n\n        if (timeline1 === undefined) {\n            return null;\n        }\n        if (timeline2 === undefined) {\n            return null;\n        }\n\n        if (timeline1 === timeline2) {\n            // both events are in the same timeline - figure out their\n            // relative indices\n            let idx1: number;\n            let idx2: number;\n            const events = timeline1.getEvents();\n            for (let idx = 0; idx < events.length &&\n            (idx1 === undefined || idx2 === undefined); idx++) {\n                const evId = events[idx].getId();\n                if (evId == eventId1) {\n                    idx1 = idx;\n                }\n                if (evId == eventId2) {\n                    idx2 = idx;\n                }\n            }\n            return idx1 - idx2;\n        }\n\n        // the events are in different timelines. Iterate through the\n        // linkedlist to see which comes first.\n\n        // first work forwards from timeline1\n        let tl = timeline1;\n        while (tl) {\n            if (tl === timeline2) {\n                // timeline1 is before timeline2\n                return -1;\n            }\n            tl = tl.getNeighbouringTimeline(EventTimeline.FORWARDS);\n        }\n\n        // now try backwards from timeline1\n        tl = timeline1;\n        while (tl) {\n            if (tl === timeline2) {\n                // timeline2 is before timeline1\n                return 1;\n            }\n            tl = tl.getNeighbouringTimeline(EventTimeline.BACKWARDS);\n        }\n\n        // the timelines are not contiguous.\n        return null;\n    }\n\n    /**\n     * Determine whether a given event can sanely be added to this event timeline set,\n     * for timeline sets relating to a thread, only return true for events in the same\n     * thread timeline, for timeline sets not relating to a thread only return true\n     * for events which should be shown in the main room timeline.\n     * Requires the `room` property to have been set at EventTimelineSet construction time.\n     *\n     * @param event {MatrixEvent} the event to check whether it belongs to this timeline set.\n     * @throws {Error} if `room` was not set when constructing this timeline set.\n     * @return {boolean} whether the event belongs to this timeline set.\n     */\n    public canContain(event: MatrixEvent): boolean {\n        if (!this.room) {\n            throw new Error(\"Cannot call `EventTimelineSet::canContain without a `room` set. \" +\n                \"Set the room when creating the EventTimelineSet to call this method.\");\n        }\n\n        const { threadId, shouldLiveInRoom } = this.room.eventShouldLiveIn(event);\n\n        if (this.thread) {\n            return this.thread.id === threadId;\n        }\n        return shouldLiveInRoom;\n    }\n}\n\n/**\n * Fires whenever the timeline in a room is updated.\n * @event module:client~MatrixClient#\"Room.timeline\"\n * @param {MatrixEvent} event The matrix event which caused this event to fire.\n * @param {?Room} room The room, if any, whose timeline was updated.\n * @param {boolean} toStartOfTimeline True if this event was added to the start\n * @param {boolean} removed True if this event has just been removed from the timeline\n * (beginning; oldest) of the timeline e.g. due to pagination.\n *\n * @param {object} data  more data about the event\n *\n * @param {module:models/event-timeline.EventTimeline} data.timeline the timeline the\n * event was added to/removed from\n *\n * @param {boolean} data.liveEvent true if the event was a real-time event\n * added to the end of the live timeline\n *\n * @example\n * matrixClient.on(\"Room.timeline\",\n *                 function(event, room, toStartOfTimeline, removed, data) {\n *   if (!toStartOfTimeline && data.liveEvent) {\n *     var messageToAppend = room.timeline.[room.timeline.length - 1];\n *   }\n * });\n */\n\n/**\n * Fires whenever the live timeline in a room is reset.\n *\n * When we get a 'limited' sync (for example, after a network outage), we reset\n * the live timeline to be empty before adding the recent events to the new\n * timeline. This event is fired after the timeline is reset, and before the\n * new events are added.\n *\n * @event module:client~MatrixClient#\"Room.timelineReset\"\n * @param {Room} room The room whose live timeline was reset, if any\n * @param {EventTimelineSet} timelineSet timelineSet room whose live timeline was reset\n * @param {boolean} resetAllTimelines True if all timelines were reset.\n */\n"],"mappings":"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"}