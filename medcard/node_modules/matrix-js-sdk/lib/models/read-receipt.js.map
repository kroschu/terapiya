{"version":3,"file":"read-receipt.js","names":["MAIN_ROOM_TIMELINE","synthesizeReceipt","userId","event","receiptType","MatrixEvent","content","getId","ts","getTs","threadId","threadRootId","type","EventType","Receipt","room_id","getRoomId","ReceiptPairRealIndex","ReceiptPairSyntheticIndex","ReadReceipt","TypedEventEmitter","getReadReceiptForUserId","ignoreSynthesized","ReceiptType","Read","realReceipt","syntheticReceipt","receipts","getEventReadUpTo","timelineSet","getUnfilteredTimelineSet","publicReadReceipt","privateReadReceipt","ReadPrivate","comparison","eventId","compareEventOrdering","data","addReceiptToStructure","receipt","synthetic","pair","existingReceipt","ordering","wrappedReceipt","preferSynthetic","cachedReceipt","newCachedReceipt","receiptCacheByEventId","previousEventId","filter","r","length","push","getReceiptsForEvent","addLocalEchoReceipt","e","addReceipt","getUsersReadUpTo","utils","isSupportedReceiptType","map","hasUserReadEvent","readUpToId","timeline","getSender","i","ev"],"sources":["../../src/models/read-receipt.ts"],"sourcesContent":["/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { ReceiptType } from \"../@types/read_receipts\";\nimport { EventTimelineSet, EventType, MatrixEvent } from \"../matrix\";\nimport { ListenerMap, TypedEventEmitter } from \"./typed-event-emitter\";\nimport * as utils from \"../utils\";\n\nexport const MAIN_ROOM_TIMELINE = \"main\";\n\nexport function synthesizeReceipt(userId: string, event: MatrixEvent, receiptType: ReceiptType): MatrixEvent {\n    return new MatrixEvent({\n        content: {\n            [event.getId()]: {\n                [receiptType]: {\n                    [userId]: {\n                        ts: event.getTs(),\n                        threadId: event.threadRootId ?? MAIN_ROOM_TIMELINE,\n                    },\n                },\n            },\n        },\n        type: EventType.Receipt,\n        room_id: event.getRoomId(),\n    });\n}\n\nexport interface Receipt {\n    ts: number;\n    thread_id?: string;\n}\n\nexport interface WrappedReceipt {\n    eventId: string;\n    data: Receipt;\n}\n\ninterface CachedReceipt {\n    type: ReceiptType;\n    userId: string;\n    data: Receipt;\n}\n\ntype ReceiptCache = {[eventId: string]: CachedReceipt[]};\n\nexport interface ReceiptContent {\n    [eventId: string]: {\n        [key in ReceiptType]: {\n            [userId: string]: Receipt;\n        };\n    };\n}\n\nconst ReceiptPairRealIndex = 0;\nconst ReceiptPairSyntheticIndex = 1;\n// We will only hold a synthetic receipt if we do not have a real receipt or the synthetic is newer.\ntype Receipts = {\n    [receiptType: string]: {\n        [userId: string]: [WrappedReceipt | null, WrappedReceipt | null]; // Pair<real receipt, synthetic receipt> (both nullable)\n    };\n};\n\nexport abstract class ReadReceipt<\n    Events extends string,\n    Arguments extends ListenerMap<Events>,\n    SuperclassArguments extends ListenerMap<any> = Arguments,\n> extends TypedEventEmitter<Events, Arguments, SuperclassArguments> {\n    // receipts should clobber based on receipt_type and user_id pairs hence\n    // the form of this structure. This is sub-optimal for the exposed APIs\n    // which pass in an event ID and get back some receipts, so we also store\n    // a pre-cached list for this purpose.\n    private receipts: Receipts = {}; // { receipt_type: { user_id: Receipt } }\n    private receiptCacheByEventId: ReceiptCache = {}; // { event_id: CachedReceipt[] }\n\n    public abstract getUnfilteredTimelineSet(): EventTimelineSet;\n    public abstract timeline: MatrixEvent[];\n\n    /**\n     * Gets the latest receipt for a given user in the room\n     * @param userId The id of the user for which we want the receipt\n     * @param ignoreSynthesized Whether to ignore synthesized receipts or not\n     * @param receiptType Optional. The type of the receipt we want to get\n     * @returns the latest receipts of the chosen type for the chosen user\n     */\n    public getReadReceiptForUserId(\n        userId: string, ignoreSynthesized = false, receiptType = ReceiptType.Read,\n    ): WrappedReceipt | null {\n        const [realReceipt, syntheticReceipt] = this.receipts[receiptType]?.[userId] ?? [];\n        if (ignoreSynthesized) {\n            return realReceipt;\n        }\n\n        return syntheticReceipt ?? realReceipt;\n    }\n\n    /**\n     * Get the ID of the event that a given user has read up to, or null if we\n     * have received no read receipts from them.\n     * @param {String} userId The user ID to get read receipt event ID for\n     * @param {Boolean} ignoreSynthesized If true, return only receipts that have been\n     *                                    sent by the server, not implicit ones generated\n     *                                    by the JS SDK.\n     * @return {String} ID of the latest event that the given user has read, or null.\n     */\n    public getEventReadUpTo(userId: string, ignoreSynthesized = false): string | null {\n        // XXX: This is very very ugly and I hope I won't have to ever add a new\n        // receipt type here again. IMHO this should be done by the server in\n        // some more intelligent manner or the client should just use timestamps\n\n        const timelineSet = this.getUnfilteredTimelineSet();\n        const publicReadReceipt = this.getReadReceiptForUserId(userId, ignoreSynthesized, ReceiptType.Read);\n        const privateReadReceipt = this.getReadReceiptForUserId(userId, ignoreSynthesized, ReceiptType.ReadPrivate);\n\n        // If we have both, compare them\n        let comparison: number | null | undefined;\n        if (publicReadReceipt?.eventId && privateReadReceipt?.eventId) {\n            comparison = timelineSet.compareEventOrdering(publicReadReceipt?.eventId, privateReadReceipt?.eventId);\n        }\n\n        // If we didn't get a comparison try to compare the ts of the receipts\n        if (!comparison && publicReadReceipt?.data?.ts && privateReadReceipt?.data?.ts) {\n            comparison = publicReadReceipt?.data?.ts - privateReadReceipt?.data?.ts;\n        }\n\n        // The public receipt is more likely to drift out of date so the private\n        // one has precedence\n        if (!comparison) return privateReadReceipt?.eventId ?? publicReadReceipt?.eventId ?? null;\n\n        // If public read receipt is older, return the private one\n        return ((comparison < 0) ? privateReadReceipt?.eventId : publicReadReceipt?.eventId) ?? null;\n    }\n\n    public addReceiptToStructure(\n        eventId: string,\n        receiptType: ReceiptType,\n        userId: string,\n        receipt: Receipt,\n        synthetic: boolean,\n    ): void {\n        if (!this.receipts[receiptType]) {\n            this.receipts[receiptType] = {};\n        }\n        if (!this.receipts[receiptType][userId]) {\n            this.receipts[receiptType][userId] = [null, null];\n        }\n\n        const pair = this.receipts[receiptType][userId];\n\n        let existingReceipt = pair[ReceiptPairRealIndex];\n        if (synthetic) {\n            existingReceipt = pair[ReceiptPairSyntheticIndex] ?? pair[ReceiptPairRealIndex];\n        }\n\n        if (existingReceipt) {\n            // we only want to add this receipt if we think it is later than the one we already have.\n            // This is managed server-side, but because we synthesize RRs locally we have to do it here too.\n            const ordering = this.getUnfilteredTimelineSet().compareEventOrdering(\n                existingReceipt.eventId,\n                eventId,\n            );\n            if (ordering !== null && ordering >= 0) {\n                return;\n            }\n        }\n\n        const wrappedReceipt: WrappedReceipt = {\n            eventId,\n            data: receipt,\n        };\n\n        const realReceipt = synthetic ? pair[ReceiptPairRealIndex] : wrappedReceipt;\n        const syntheticReceipt = synthetic ? wrappedReceipt : pair[ReceiptPairSyntheticIndex];\n\n        let ordering: number | null = null;\n        if (realReceipt && syntheticReceipt) {\n            ordering = this.getUnfilteredTimelineSet().compareEventOrdering(\n                realReceipt.eventId,\n                syntheticReceipt.eventId,\n            );\n        }\n\n        const preferSynthetic = ordering === null || ordering < 0;\n\n        // we don't bother caching just real receipts by event ID as there's nothing that would read it.\n        // Take the current cached receipt before we overwrite the pair elements.\n        const cachedReceipt = pair[ReceiptPairSyntheticIndex] ?? pair[ReceiptPairRealIndex];\n\n        if (synthetic && preferSynthetic) {\n            pair[ReceiptPairSyntheticIndex] = wrappedReceipt;\n        } else if (!synthetic) {\n            pair[ReceiptPairRealIndex] = wrappedReceipt;\n\n            if (!preferSynthetic) {\n                pair[ReceiptPairSyntheticIndex] = null;\n            }\n        }\n\n        const newCachedReceipt = pair[ReceiptPairSyntheticIndex] ?? pair[ReceiptPairRealIndex];\n        if (cachedReceipt === newCachedReceipt) return;\n\n        // clean up any previous cache entry\n        if (cachedReceipt && this.receiptCacheByEventId[cachedReceipt.eventId]) {\n            const previousEventId = cachedReceipt.eventId;\n            // Remove the receipt we're about to clobber out of existence from the cache\n            this.receiptCacheByEventId[previousEventId] = (\n                this.receiptCacheByEventId[previousEventId].filter(r => {\n                    return r.type !== receiptType || r.userId !== userId;\n                })\n            );\n\n            if (this.receiptCacheByEventId[previousEventId].length < 1) {\n                delete this.receiptCacheByEventId[previousEventId]; // clean up the cache keys\n            }\n        }\n\n        // cache the new one\n        if (!this.receiptCacheByEventId[eventId]) {\n            this.receiptCacheByEventId[eventId] = [];\n        }\n        this.receiptCacheByEventId[eventId].push({\n            userId: userId,\n            type: receiptType as ReceiptType,\n            data: receipt,\n        });\n    }\n\n    /**\n     * Get a list of receipts for the given event.\n     * @param {MatrixEvent} event the event to get receipts for\n     * @return {Object[]} A list of receipts with a userId, type and data keys or\n     * an empty list.\n     */\n    public getReceiptsForEvent(event: MatrixEvent): CachedReceipt[] {\n        return this.receiptCacheByEventId[event.getId()] || [];\n    }\n\n    public abstract addReceipt(event: MatrixEvent, synthetic: boolean): void;\n\n    /**\n     * Add a temporary local-echo receipt to the room to reflect in the\n     * client the fact that we've sent one.\n     * @param {string} userId The user ID if the receipt sender\n     * @param {MatrixEvent} e The event that is to be acknowledged\n     * @param {ReceiptType} receiptType The type of receipt\n     */\n    public addLocalEchoReceipt(userId: string, e: MatrixEvent, receiptType: ReceiptType): void {\n        this.addReceipt(synthesizeReceipt(userId, e, receiptType), true);\n    }\n\n    /**\n     * Get a list of user IDs who have <b>read up to</b> the given event.\n     * @param {MatrixEvent} event the event to get read receipts for.\n     * @return {String[]} A list of user IDs.\n     */\n    public getUsersReadUpTo(event: MatrixEvent): string[] {\n        return this.getReceiptsForEvent(event).filter(function(receipt) {\n            return utils.isSupportedReceiptType(receipt.type);\n        }).map(function(receipt) {\n            return receipt.userId;\n        });\n    }\n\n    /**\n     * Determines if the given user has read a particular event ID with the known\n     * history of the room. This is not a definitive check as it relies only on\n     * what is available to the room at the time of execution.\n     * @param {String} userId The user ID to check the read state of.\n     * @param {String} eventId The event ID to check if the user read.\n     * @returns {Boolean} True if the user has read the event, false otherwise.\n     */\n    public hasUserReadEvent(userId: string, eventId: string): boolean {\n        const readUpToId = this.getEventReadUpTo(userId, false);\n        if (readUpToId === eventId) return true;\n\n        if (this.timeline.length\n            && this.timeline[this.timeline.length - 1].getSender()\n            && this.timeline[this.timeline.length - 1].getSender() === userId) {\n            // It doesn't matter where the event is in the timeline, the user has read\n            // it because they've sent the latest event.\n            return true;\n        }\n\n        for (let i = this.timeline.length - 1; i >= 0; --i) {\n            const ev = this.timeline[i];\n\n            // If we encounter the target event first, the user hasn't read it\n            // however if we encounter the readUpToId first then the user has read\n            // it. These rules apply because we're iterating bottom-up.\n            if (ev.getId() === eventId) return false;\n            if (ev.getId() === readUpToId) return true;\n        }\n\n        // We don't know if the user has read it, so assume not.\n        return false;\n    }\n}\n"],"mappings":"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"}