{"version":3,"file":"scheduler.js","names":["DEBUG","MatrixScheduler","RETRY_BACKOFF_RATELIMIT","event","attempts","err","httpStatus","name","waitTime","data","retry_after_ms","Math","pow","QUEUE_MESSAGES","getType","EventType","RoomMessage","hasAssocation","constructor","retryAlgorithm","queueAlgorithm","queueName","obj","peekNextEvent","index","activeQueues","indexOf","splice","debuglog","queues","length","Promise","resolve","then","procFn","res","removeNextEvent","getId","defer","processQueue","waitTimeMs","reject","setTimeout","getQueueForEvent","map","removeEventFromQueue","removed","utils","removeElement","element","setProcessFunction","fn","startProcessingQueues","queueEvent","push","promise","Object","keys","filter","forEach","queue","Array","isArray","shift","args","logger","log"],"sources":["../src/scheduler.ts"],"sourcesContent":["/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module which manages queuing, scheduling and retrying\n * of requests.\n * @module scheduler\n */\nimport * as utils from \"./utils\";\nimport { logger } from './logger';\nimport { MatrixEvent } from \"./models/event\";\nimport { EventType } from \"./@types/event\";\nimport { IDeferred } from \"./utils\";\nimport { MatrixError } from \"./http-api\";\nimport { ISendEventResponse } from \"./@types/requests\";\n\nconst DEBUG = false;  // set true to enable console logging.\n\ninterface IQueueEntry<T> {\n    event: MatrixEvent;\n    defer: IDeferred<T>;\n    attempts: number;\n}\n\ntype ProcessFunction<T> = (event: MatrixEvent) => Promise<T>;\n\n/**\n * Construct a scheduler for Matrix. Requires\n * {@link module:scheduler~MatrixScheduler#setProcessFunction} to be provided\n * with a way of processing events.\n * @constructor\n * @param {module:scheduler~retryAlgorithm} retryAlgorithm Optional. The retry\n * algorithm to apply when determining when to try to send an event again.\n * Defaults to {@link module:scheduler~MatrixScheduler.RETRY_BACKOFF_RATELIMIT}.\n * @param {module:scheduler~queueAlgorithm} queueAlgorithm Optional. The queuing\n * algorithm to apply when determining which events should be sent before the\n * given event. Defaults to {@link module:scheduler~MatrixScheduler.QUEUE_MESSAGES}.\n */\n// eslint-disable-next-line camelcase\nexport class MatrixScheduler<T = ISendEventResponse> {\n    /**\n     * Retries events up to 4 times using exponential backoff. This produces wait\n     * times of 2, 4, 8, and 16 seconds (30s total) after which we give up. If the\n     * failure was due to a rate limited request, the time specified in the error is\n     * waited before being retried.\n     * @param {MatrixEvent} event\n     * @param {Number} attempts Number of attempts that have been made, including the one that just failed (ie. starting at 1)\n     * @param {MatrixError} err\n     * @return {Number}\n     * @see module:scheduler~retryAlgorithm\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public static RETRY_BACKOFF_RATELIMIT(event: MatrixEvent, attempts: number, err: MatrixError): number {\n        if (err.httpStatus === 400 || err.httpStatus === 403 || err.httpStatus === 401) {\n            // client error; no amount of retrying with save you now.\n            return -1;\n        }\n        // we ship with browser-request which returns { cors: rejected } when trying\n        // with no connection, so if we match that, give up since they have no conn.\n        if (err[\"cors\"] === \"rejected\") {\n            return -1;\n        }\n\n        // if event that we are trying to send is too large in any way then retrying won't help\n        if (err.name === \"M_TOO_LARGE\") {\n            return -1;\n        }\n\n        if (err.name === \"M_LIMIT_EXCEEDED\") {\n            const waitTime = err.data.retry_after_ms;\n            if (waitTime > 0) {\n                return waitTime;\n            }\n        }\n        if (attempts > 4) {\n            return -1; // give up\n        }\n        return (1000 * Math.pow(2, attempts));\n    }\n\n    /**\n     * Queues <code>m.room.message</code> events and lets other events continue\n     * concurrently.\n     * @param {MatrixEvent} event\n     * @return {string}\n     * @see module:scheduler~queueAlgorithm\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public static QUEUE_MESSAGES(event: MatrixEvent) {\n        // enqueue messages or events that associate with another event (redactions and relations)\n        if (event.getType() === EventType.RoomMessage || event.hasAssocation()) {\n            // put these events in the 'message' queue.\n            return \"message\";\n        }\n        // allow all other events continue concurrently.\n        return null;\n    }\n\n    // queueName: [{\n    //  event: MatrixEvent,  // event to send\n    //  defer: Deferred,  // defer to resolve/reject at the END of the retries\n    //  attempts: Number  // number of times we've called processFn\n    // }, ...]\n    private readonly queues: Record<string, IQueueEntry<T>[]> = {};\n    private activeQueues: string[] = [];\n    private procFn: ProcessFunction<T> = null;\n\n    constructor(\n        public readonly retryAlgorithm = MatrixScheduler.RETRY_BACKOFF_RATELIMIT,\n        public readonly queueAlgorithm = MatrixScheduler.QUEUE_MESSAGES,\n    ) {}\n\n    /**\n     * Retrieve a queue based on an event. The event provided does not need to be in\n     * the queue.\n     * @param {MatrixEvent} event An event to get the queue for.\n     * @return {?Array<MatrixEvent>} A shallow copy of events in the queue or null.\n     * Modifying this array will not modify the list itself. Modifying events in\n     * this array <i>will</i> modify the underlying event in the queue.\n     * @see MatrixScheduler.removeEventFromQueue To remove an event from the queue.\n     */\n    public getQueueForEvent(event: MatrixEvent): MatrixEvent[] {\n        const name = this.queueAlgorithm(event);\n        if (!name || !this.queues[name]) {\n            return null;\n        }\n        return this.queues[name].map(function(obj) {\n            return obj.event;\n        });\n    }\n\n    /**\n     * Remove this event from the queue. The event is equal to another event if they\n     * have the same ID returned from event.getId().\n     * @param {MatrixEvent} event The event to remove.\n     * @return {boolean} True if this event was removed.\n     */\n    public removeEventFromQueue(event: MatrixEvent): boolean {\n        const name = this.queueAlgorithm(event);\n        if (!name || !this.queues[name]) {\n            return false;\n        }\n        let removed = false;\n        utils.removeElement(this.queues[name], (element) => {\n            if (element.event.getId() === event.getId()) {\n                // XXX we should probably reject the promise?\n                // https://github.com/matrix-org/matrix-js-sdk/issues/496\n                removed = true;\n                return true;\n            }\n        });\n        return removed;\n    }\n\n    /**\n     * Set the process function. Required for events in the queue to be processed.\n     * If set after events have been added to the queue, this will immediately start\n     * processing them.\n     * @param {module:scheduler~processFn} fn The function that can process events\n     * in the queue.\n     */\n    public setProcessFunction(fn: ProcessFunction<T>): void {\n        this.procFn = fn;\n        this.startProcessingQueues();\n    }\n\n    /**\n     * Queue an event if it is required and start processing queues.\n     * @param {MatrixEvent} event The event that may be queued.\n     * @return {?Promise} A promise if the event was queued, which will be\n     * resolved or rejected in due time, else null.\n     */\n    public queueEvent(event: MatrixEvent): Promise<T> | null {\n        const queueName = this.queueAlgorithm(event);\n        if (!queueName) {\n            return null;\n        }\n        // add the event to the queue and make a deferred for it.\n        if (!this.queues[queueName]) {\n            this.queues[queueName] = [];\n        }\n        const defer = utils.defer<T>();\n        this.queues[queueName].push({\n            event: event,\n            defer: defer,\n            attempts: 0,\n        });\n        debuglog(\"Queue algorithm dumped event %s into queue '%s'\", event.getId(), queueName);\n        this.startProcessingQueues();\n        return defer.promise;\n    }\n\n    private startProcessingQueues(): void {\n        if (!this.procFn) return;\n        // for each inactive queue with events in them\n        Object.keys(this.queues)\n            .filter((queueName) => {\n                return this.activeQueues.indexOf(queueName) === -1 &&\n                    this.queues[queueName].length > 0;\n            })\n            .forEach((queueName) => {\n                // mark the queue as active\n                this.activeQueues.push(queueName);\n                // begin processing the head of the queue\n                debuglog(\"Spinning up queue: '%s'\", queueName);\n                this.processQueue(queueName);\n            });\n    }\n\n    private processQueue = (queueName: string): void => {\n        // get head of queue\n        const obj = this.peekNextEvent(queueName);\n        if (!obj) {\n            // queue is empty. Mark as inactive and stop recursing.\n            const index = this.activeQueues.indexOf(queueName);\n            if (index >= 0) {\n                this.activeQueues.splice(index, 1);\n            }\n            debuglog(\"Stopping queue '%s' as it is now empty\", queueName);\n            return;\n        }\n        debuglog(\"Queue '%s' has %s pending events\", queueName, this.queues[queueName].length);\n        // fire the process function and if it resolves, resolve the deferred. Else\n        // invoke the retry algorithm.\n\n        // First wait for a resolved promise, so the resolve handlers for\n        // the deferred of the previously sent event can run.\n        // This way enqueued relations/redactions to enqueued events can receive\n        // the remove id of their target before being sent.\n        Promise.resolve().then(() => {\n            return this.procFn(obj.event);\n        }).then((res) => {\n            // remove this from the queue\n            this.removeNextEvent(queueName);\n            debuglog(\"Queue '%s' sent event %s\", queueName, obj.event.getId());\n            obj.defer.resolve(res);\n            // keep processing\n            this.processQueue(queueName);\n        }, (err) => {\n            obj.attempts += 1;\n            // ask the retry algorithm when/if we should try again\n            const waitTimeMs = this.retryAlgorithm(obj.event, obj.attempts, err);\n            debuglog(\"retry(%s) err=%s event_id=%s waitTime=%s\", obj.attempts, err, obj.event.getId(), waitTimeMs);\n            if (waitTimeMs === -1) {  // give up (you quitter!)\n                debuglog(\"Queue '%s' giving up on event %s\", queueName, obj.event.getId());\n                // remove this from the queue\n                this.removeNextEvent(queueName);\n                obj.defer.reject(err);\n                // process next event\n                this.processQueue(queueName);\n            } else {\n                setTimeout(this.processQueue, waitTimeMs, queueName);\n            }\n        });\n    };\n\n    private peekNextEvent(queueName: string): IQueueEntry<T> {\n        const queue = this.queues[queueName];\n        if (!Array.isArray(queue)) {\n            return null;\n        }\n        return queue[0];\n    }\n\n    private removeNextEvent(queueName: string): IQueueEntry<T> {\n        const queue = this.queues[queueName];\n        if (!Array.isArray(queue)) {\n            return null;\n        }\n        return queue.shift();\n    }\n}\n\nfunction debuglog(...args: any[]) {\n    if (DEBUG) {\n        logger.log(...args);\n    }\n}\n\n/**\n * The retry algorithm to apply when retrying events. To stop retrying, return\n * <code>-1</code>. If this event was part of a queue, it will be removed from\n * the queue.\n * @callback retryAlgorithm\n * @param {MatrixEvent} event The event being retried.\n * @param {Number} attempts The number of failed attempts. This will always be\n * >= 1.\n * @param {MatrixError} err The most recent error message received when trying\n * to send this event.\n * @return {Number} The number of milliseconds to wait before trying again. If\n * this is 0, the request will be immediately retried. If this is\n * <code>-1</code>, the event will be marked as\n * {@link module:models/event.EventStatus.NOT_SENT} and will not be retried.\n */\n\n/**\n * The queuing algorithm to apply to events. This function must be idempotent as\n * it may be called multiple times with the same event. All queues created are\n * serviced in a FIFO manner. To send the event ASAP, return <code>null</code>\n * which will not put this event in a queue. Events that fail to send that form\n * part of a queue will be removed from the queue and the next event in the\n * queue will be sent.\n * @callback queueAlgorithm\n * @param {MatrixEvent} event The event to be sent.\n * @return {string} The name of the queue to put the event into. If a queue with\n * this name does not exist, it will be created. If this is <code>null</code>,\n * the event is not put into a queue and will be sent concurrently.\n */\n\n/**\n * The function to invoke to process (send) events in the queue.\n * @callback processFn\n * @param {MatrixEvent} event The event to send.\n * @return {Promise} Resolved/rejected depending on the outcome of the request.\n */\n\n"],"mappings":"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"}