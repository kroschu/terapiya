{"version":3,"file":"sliding-sync.js","names":["BUFFER_PERIOD_MS","SlidingSyncState","SlidingList","constructor","list","replaceList","setModified","modified","isModified","updateListRange","newRanges","ranges","JSON","parse","stringify","filters","roomIndexToRoomId","joinedCount","getList","forceIncludeAllParams","isIndexInRange","i","r","ExtensionState","SlidingSyncEvent","SlidingSync","TypedEventEmitter","proxyBaseUrl","lists","roomSubscriptionInfo","client","timeoutMS","Set","map","l","listLength","length","getListData","index","Object","assign","setListRanges","resend","setList","listModifiedCount","getRoomSubscriptions","Array","from","desiredRoomSubscriptions","modifyRoomSubscriptions","s","modifyRoomSubscriptionInfo","rs","confirmedRoomSubscriptions","registerExtension","ext","extensions","name","Error","getExtensionRequest","isInitial","keys","forEach","extName","onRequest","onPreExtensionsResponse","when","PreProcess","onResponse","onPostExtensionsResponse","PostProcess","invokeRoomDataListeners","roomId","roomData","required_state","timeline","emit","RoomData","invokeLifecycleListeners","state","resp","err","Lifecycle","shiftRight","listIndex","hi","low","shiftLeft","removeEntry","max","n","Number","addEntry","processListOps","gapIndex","ops","op","logger","debug","room_id","startIndex","range","room_ids","join","needsResend","txnIdDefers","promise","txnId","makeTxnId","d","defer","push","pendingReq","abort","resolveTransactionDefers","txnIndex","warn","reject","resolve","slice","stop","terminated","removeAllListeners","List","start","currentPos","doNotUpdateList","reqBody","pos","timeout","clientTimeout","undefined","newSubscriptions","difference","unsubscriptions","size","unsubscribe_rooms","room_subscriptions","txn_id","slidingSync","add","delete","rooms","val","count","RequestFinished","httpStatus","sleep","error","listIndexesWithUpdates","Complete","setA","setB","diff","elem"],"sources":["../src/sliding-sync.ts"],"sourcesContent":["/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { logger } from './logger';\nimport { IAbortablePromise } from \"./@types/partials\";\nimport { MatrixClient } from \"./client\";\nimport { IRoomEvent, IStateEvent } from \"./sync-accumulator\";\nimport { TypedEventEmitter } from \"./models//typed-event-emitter\";\nimport { sleep, IDeferred, defer } from \"./utils\";\n\n// /sync requests allow you to set a timeout= but the request may continue\n// beyond that and wedge forever, so we need to track how long we are willing\n// to keep open the connection. This constant is *ADDED* to the timeout= value\n// to determine the max time we're willing to wait.\nconst BUFFER_PERIOD_MS = 10 * 1000;\n\n/**\n * Represents a subscription to a room or set of rooms. Controls which events are returned.\n */\nexport interface MSC3575RoomSubscription {\n    required_state?: string[][];\n    timeline_limit?: number;\n}\n\n/**\n * Controls which rooms are returned in a given list.\n */\nexport interface MSC3575Filter {\n    is_dm?: boolean;\n    is_encrypted?: boolean;\n    is_invite?: boolean;\n    is_tombstoned?: boolean;\n    room_name_like?: string;\n    room_types?: string[];\n    not_room_types?: string[];\n    spaces?: string[];\n    tags?: string[];\n    not_tags?: string[];\n}\n\n/**\n * Represents a list subscription.\n */\nexport interface MSC3575List extends MSC3575RoomSubscription {\n    ranges: number[][];\n    sort?: string[];\n    filters?: MSC3575Filter;\n    slow_get_all_rooms?: boolean;\n}\n\n/**\n * A complete Sliding Sync request.\n */\nexport interface MSC3575SlidingSyncRequest {\n    // json body params\n    lists?: MSC3575List[];\n    unsubscribe_rooms?: string[];\n    room_subscriptions?: Record<string, MSC3575RoomSubscription>;\n    extensions?: object;\n    txn_id?: string;\n\n    // query params\n    pos?: string;\n    timeout?: number;\n    clientTimeout?: number;\n}\n\nexport interface MSC3575RoomData {\n    name: string;\n    required_state: IStateEvent[];\n    timeline: (IRoomEvent | IStateEvent)[];\n    notification_count?: number;\n    highlight_count?: number;\n    joined_count?: number;\n    invited_count?: number;\n    invite_state?: IStateEvent[];\n    initial?: boolean;\n    limited?: boolean;\n    is_dm?: boolean;\n    prev_batch?: string;\n}\n\ninterface ListResponse {\n    count: number;\n    ops: Operation[];\n}\n\ninterface BaseOperation {\n    op: string;\n}\n\ninterface DeleteOperation extends BaseOperation {\n    op: \"DELETE\";\n    index: number;\n}\n\ninterface InsertOperation extends BaseOperation {\n    op: \"INSERT\";\n    index: number;\n    room_id: string;\n}\n\ninterface InvalidateOperation extends BaseOperation {\n    op: \"INVALIDATE\";\n    range: [number, number];\n}\n\ninterface SyncOperation extends BaseOperation {\n    op: \"SYNC\";\n    range: [number, number];\n    room_ids: string[];\n}\n\ntype Operation = DeleteOperation | InsertOperation | InvalidateOperation | SyncOperation;\n\n/**\n * A complete Sliding Sync response\n */\nexport interface MSC3575SlidingSyncResponse {\n    pos: string;\n    txn_id?: string;\n    lists: ListResponse[];\n    rooms: Record<string, MSC3575RoomData>;\n    extensions: object;\n}\n\nexport enum SlidingSyncState {\n    /**\n     * Fired by SlidingSyncEvent.Lifecycle event immediately before processing the response.\n     */\n    RequestFinished = \"FINISHED\",\n    /**\n     * Fired by SlidingSyncEvent.Lifecycle event immediately after all room data listeners have been\n     * invoked, but before list listeners.\n     */\n    Complete = \"COMPLETE\",\n}\n\n/**\n * Internal Class. SlidingList represents a single list in sliding sync. The list can have filters,\n * multiple sliding windows, and maintains the index->room_id mapping.\n */\nclass SlidingList {\n    private list: MSC3575List;\n    private isModified: boolean;\n\n    // returned data\n    public roomIndexToRoomId: Record<number, string>;\n    public joinedCount: number;\n\n    /**\n     * Construct a new sliding list.\n     * @param {MSC3575List} list The range, sort and filter values to use for this list.\n     */\n    constructor(list: MSC3575List) {\n        this.replaceList(list);\n    }\n\n    /**\n     * Mark this list as modified or not. Modified lists will return sticky params with calls to getList.\n     * This is useful for the first time the list is sent, or if the list has changed in some way.\n     * @param modified True to mark this list as modified so all sticky parameters will be re-sent.\n     */\n    public setModified(modified: boolean): void {\n        this.isModified = modified;\n    }\n\n    /**\n     * Update the list range for this list. Does not affect modified status as list ranges are non-sticky.\n     * @param newRanges The new ranges for the list\n     */\n    public updateListRange(newRanges: number[][]): void {\n        this.list.ranges = JSON.parse(JSON.stringify(newRanges));\n    }\n\n    /**\n     * Replace list parameters. All fields will be replaced with the new list parameters.\n     * @param list The new list parameters\n     */\n    public replaceList(list: MSC3575List): void {\n        list.filters = list.filters || {};\n        list.ranges = list.ranges || [];\n        this.list = JSON.parse(JSON.stringify(list));\n        this.isModified = true;\n\n        // reset values as the join count may be very different (if filters changed) including the rooms\n        // (e.g. sort orders or sliding window ranges changed)\n\n        // the constantly changing sliding window ranges. Not an array for performance reasons\n        // E.g. tracking ranges 0-99, 500-599, we don't want to have a 600 element array\n        this.roomIndexToRoomId = {};\n        // the total number of joined rooms according to the server, always >= len(roomIndexToRoomId)\n        this.joinedCount = 0;\n    }\n\n    /**\n     * Return a copy of the list suitable for a request body.\n     * @param {boolean} forceIncludeAllParams True to forcibly include all params even if the list\n     * hasn't been modified. Callers may want to do this if they are modifying the list prior to calling\n     * updateList.\n     */\n    public getList(forceIncludeAllParams: boolean): MSC3575List {\n        let list = {\n            ranges: JSON.parse(JSON.stringify(this.list.ranges)),\n        };\n        if (this.isModified || forceIncludeAllParams) {\n            list = JSON.parse(JSON.stringify(this.list));\n        }\n        return list;\n    }\n\n    /**\n     * Check if a given index is within the list range. This is required even though the /sync API\n     * provides explicit updates with index positions because of the following situation:\n     *   0 1 2 3 4 5 6 7 8   indexes\n     *   a b c       d e f   COMMANDS: SYNC 0 2 a b c; SYNC 6 8 d e f;\n     *   a b c       d _ f   COMMAND: DELETE 7;\n     *   e a b c       d f   COMMAND: INSERT 0 e;\n     *   c=3 is wrong as we are not tracking it, ergo we need to see if `i` is in range else drop it\n     * @param i The index to check\n     * @returns True if the index is within a sliding window\n     */\n    public isIndexInRange(i: number): boolean {\n        for (const r of this.list.ranges) {\n            if (r[0] <= i && i <= r[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * When onResponse extensions should be invoked: before or after processing the main response.\n */\nexport enum ExtensionState {\n    // Call onResponse before processing the response body. This is useful when your extension is\n    // preparing the ground for the response body e.g. processing to-device messages before the\n    // encrypted event arrives.\n    PreProcess = \"ExtState.PreProcess\",\n    // Call onResponse after processing the response body. This is useful when your extension is\n    // decorating data from the client, and you rely on MatrixClient.getRoom returning the Room object\n    // e.g. room account data.\n    PostProcess = \"ExtState.PostProcess\",\n}\n\n/**\n * An interface that must be satisfied to register extensions\n */\nexport interface Extension {\n    /**\n     * The extension name to go under 'extensions' in the request body.\n     * @returns The JSON key.\n     */\n    name(): string;\n    /**\n     * A function which is called when the request JSON is being formed.\n     * Returns the data to insert under this key.\n     * @param isInitial True when this is part of the initial request (send sticky params)\n     * @returns The request JSON to send.\n     */\n    onRequest(isInitial: boolean): object;\n    /**\n     * A function which is called when there is response JSON under this extension.\n     * @param data The response JSON under the extension name.\n     */\n    onResponse(data: object);\n    /**\n     * Controls when onResponse should be called.\n     * @returns The state when it should be called.\n     */\n    when(): ExtensionState;\n}\n\n/**\n * Events which can be fired by the SlidingSync class. These are designed to provide different levels\n * of information when processing sync responses.\n *  - RoomData: concerns rooms, useful for SlidingSyncSdk to update its knowledge of rooms.\n *  - Lifecycle: concerns callbacks at various well-defined points in the sync process.\n *  - List: concerns lists, useful for UI layers to re-render room lists.\n * Specifically, the order of event invocation is:\n *  - Lifecycle (state=RequestFinished)\n *  - RoomData (N times)\n *  - Lifecycle (state=Complete)\n *  - List (at most once per list)\n */\nexport enum SlidingSyncEvent {\n    /**\n     * This event fires when there are updates for a room. Fired as and when rooms are encountered\n     * in the response.\n     */\n    RoomData = \"SlidingSync.RoomData\",\n    /**\n     * This event fires at various points in the /sync loop lifecycle.\n     *  - SlidingSyncState.RequestFinished: Fires after we receive a valid response but before the\n     * response has been processed. Perform any pre-process steps here. If there was a problem syncing,\n     * `err` will be set (e.g network errors).\n     *  - SlidingSyncState.Complete: Fires after all SlidingSyncEvent.RoomData have been fired but before\n     * SlidingSyncEvent.List.\n     */\n    Lifecycle = \"SlidingSync.Lifecycle\",\n    /**\n     * This event fires whenever there has been a change to this list index. It fires exactly once\n     * per list, even if there were multiple operations for the list.\n     * It fires AFTER Lifecycle and RoomData events.\n     */\n    List = \"SlidingSync.List\",\n}\n\nexport type SlidingSyncEventHandlerMap = {\n    [SlidingSyncEvent.RoomData]: (roomId: string, roomData: MSC3575RoomData) => void;\n    [SlidingSyncEvent.Lifecycle]: (\n        state: SlidingSyncState, resp: MSC3575SlidingSyncResponse | null, err: Error | null,\n    ) => void;\n    [SlidingSyncEvent.List]: (\n        listIndex: number, joinedCount: number, roomIndexToRoomId: Record<number, string>,\n    ) => void;\n};\n\n/**\n * SlidingSync is a high-level data structure which controls the majority of sliding sync.\n * It has no hooks into JS SDK except for needing a MatrixClient to perform the HTTP request.\n * This means this class (and everything it uses) can be used in isolation from JS SDK if needed.\n * To hook this up with the JS SDK, you need to use SlidingSyncSdk.\n */\nexport class SlidingSync extends TypedEventEmitter<SlidingSyncEvent, SlidingSyncEventHandlerMap> {\n    private lists: SlidingList[];\n    private listModifiedCount = 0;\n    private terminated = false;\n    // flag set when resend() is called because we cannot rely on detecting AbortError in JS SDK :(\n    private needsResend = false;\n    // the txn_id to send with the next request.\n    private txnId?: string = null;\n    // a list (in chronological order of when they were sent) of objects containing the txn ID and\n    // a defer to resolve/reject depending on whether they were successfully sent or not.\n    private txnIdDefers: (IDeferred<string> & { txnId: string})[] = [];\n    // map of extension name to req/resp handler\n    private extensions: Record<string, Extension> = {};\n\n    private desiredRoomSubscriptions = new Set<string>(); // the *desired* room subscriptions\n    private confirmedRoomSubscriptions = new Set<string>();\n\n    private pendingReq?: IAbortablePromise<MSC3575SlidingSyncResponse>;\n\n    /**\n     * Create a new sliding sync instance\n     * @param {string} proxyBaseUrl The base URL of the sliding sync proxy\n     * @param {MSC3575List[]} lists The lists to use for sliding sync.\n     * @param {MSC3575RoomSubscription} roomSubscriptionInfo The params to use for room subscriptions.\n     * @param {MatrixClient} client The client to use for /sync calls.\n     * @param {number} timeoutMS The number of milliseconds to wait for a response.\n     */\n    constructor(\n        private readonly proxyBaseUrl: string,\n        lists: MSC3575List[],\n        private roomSubscriptionInfo: MSC3575RoomSubscription,\n        private readonly client: MatrixClient,\n        private readonly timeoutMS: number,\n    ) {\n        super();\n        this.lists = lists.map((l) => new SlidingList(l));\n    }\n\n    /**\n     * Get the length of the sliding lists.\n     * @returns The number of lists in the sync request\n     */\n    public listLength(): number {\n        return this.lists.length;\n    }\n\n    /**\n     * Get the room data for a list.\n     * @param index The list index\n     * @returns The list data which contains the rooms in this list\n     */\n    public getListData(index: number): {joinedCount: number, roomIndexToRoomId: Record<number, string>} {\n        if (!this.lists[index]) {\n            return null;\n        }\n        return {\n            joinedCount: this.lists[index].joinedCount,\n            roomIndexToRoomId: Object.assign({}, this.lists[index].roomIndexToRoomId),\n        };\n    }\n\n    /**\n     * Get the full list parameters for a list index. This function is provided for callers to use\n     * in conjunction with setList to update fields on an existing list.\n     * @param index The list index to get the list for.\n     * @returns A copy of the list or undefined.\n     */\n    public getList(index: number): MSC3575List {\n        if (!this.lists[index]) {\n            return null;\n        }\n        return this.lists[index].getList(true);\n    }\n\n    /**\n     * Set new ranges for an existing list. Calling this function when _only_ the ranges have changed\n     * is more efficient than calling setList(index,list) as this function won't resend sticky params,\n     * whereas setList always will.\n     * @param index The list index to modify\n     * @param ranges The new ranges to apply.\n     * @return A promise which resolves to the transaction ID when it has been received down sync\n     * (or rejects with the transaction ID if the action was not applied e.g the request was cancelled\n     * immediately after sending, in which case the action will be applied in the subsequent request)\n     */\n    public setListRanges(index: number, ranges: number[][]): Promise<string> {\n        this.lists[index].updateListRange(ranges);\n        return this.resend();\n    }\n\n    /**\n     * Add or replace a list. Calling this function will interrupt the /sync request to resend new\n     * lists.\n     * @param index The index to modify\n     * @param list The new list parameters.\n     * @return A promise which resolves to the transaction ID when it has been received down sync\n     * (or rejects with the transaction ID if the action was not applied e.g the request was cancelled\n     * immediately after sending, in which case the action will be applied in the subsequent request)\n     */\n    public setList(index: number, list: MSC3575List): Promise<string> {\n        if (this.lists[index]) {\n            this.lists[index].replaceList(list);\n        } else {\n            this.lists[index] = new SlidingList(list);\n        }\n        this.listModifiedCount += 1;\n        return this.resend();\n    }\n\n    /**\n     * Get the room subscriptions for the sync API.\n     * @returns A copy of the desired room subscriptions.\n     */\n    public getRoomSubscriptions(): Set<string> {\n        return new Set(Array.from(this.desiredRoomSubscriptions));\n    }\n\n    /**\n     * Modify the room subscriptions for the sync API. Calling this function will interrupt the\n     * /sync request to resend new subscriptions. If the /sync stream has not started, this will\n     * prepare the room subscriptions for when start() is called.\n     * @param s The new desired room subscriptions.\n     * @return A promise which resolves to the transaction ID when it has been received down sync\n     * (or rejects with the transaction ID if the action was not applied e.g the request was cancelled\n     * immediately after sending, in which case the action will be applied in the subsequent request)\n     */\n    public modifyRoomSubscriptions(s: Set<string>): Promise<string> {\n        this.desiredRoomSubscriptions = s;\n        return this.resend();\n    }\n\n    /**\n     * Modify which events to retrieve for room subscriptions. Invalidates all room subscriptions\n     * such that they will be sent up afresh.\n     * @param rs The new room subscription fields to fetch.\n     * @return A promise which resolves to the transaction ID when it has been received down sync\n     * (or rejects with the transaction ID if the action was not applied e.g the request was cancelled\n     * immediately after sending, in which case the action will be applied in the subsequent request)\n     */\n    public modifyRoomSubscriptionInfo(rs: MSC3575RoomSubscription): Promise<string> {\n        this.roomSubscriptionInfo = rs;\n        this.confirmedRoomSubscriptions = new Set<string>();\n        return this.resend();\n    }\n\n    /**\n     * Register an extension to send with the /sync request.\n     * @param ext The extension to register.\n     */\n    public registerExtension(ext: Extension): void {\n        if (this.extensions[ext.name()]) {\n            throw new Error(`registerExtension: ${ext.name()} already exists as an extension`);\n        }\n        this.extensions[ext.name()] = ext;\n    }\n\n    private getExtensionRequest(isInitial: boolean): object {\n        const ext = {};\n        Object.keys(this.extensions).forEach((extName) => {\n            ext[extName] = this.extensions[extName].onRequest(isInitial);\n        });\n        return ext;\n    }\n\n    private onPreExtensionsResponse(ext: object): void {\n        Object.keys(ext).forEach((extName) => {\n            if (this.extensions[extName].when() == ExtensionState.PreProcess) {\n                this.extensions[extName].onResponse(ext[extName]);\n            }\n        });\n    }\n\n    private onPostExtensionsResponse(ext: object): void {\n        Object.keys(ext).forEach((extName) => {\n            if (this.extensions[extName].when() == ExtensionState.PostProcess) {\n                this.extensions[extName].onResponse(ext[extName]);\n            }\n        });\n    }\n\n    /**\n     * Invoke all attached room data listeners.\n     * @param {string} roomId The room which received some data.\n     * @param {object} roomData The raw sliding sync response JSON.\n     */\n    private invokeRoomDataListeners(roomId: string, roomData: MSC3575RoomData): void {\n        if (!roomData.required_state) { roomData.required_state = []; }\n        if (!roomData.timeline) { roomData.timeline = []; }\n        this.emit(SlidingSyncEvent.RoomData, roomId, roomData);\n    }\n\n    /**\n     * Invoke all attached lifecycle listeners.\n     * @param {SlidingSyncState} state The Lifecycle state\n     * @param {object} resp The raw sync response JSON\n     * @param {Error?} err Any error that occurred when making the request e.g. network errors.\n     */\n    private invokeLifecycleListeners(state: SlidingSyncState, resp: MSC3575SlidingSyncResponse, err?: Error): void {\n        this.emit(SlidingSyncEvent.Lifecycle, state, resp, err);\n    }\n\n    private shiftRight(listIndex: number, hi: number, low: number) {\n        //     l   h\n        // 0,1,2,3,4 <- before\n        // 0,1,2,2,3 <- after, hi is deleted and low is duplicated\n        for (let i = hi; i > low; i--) {\n            if (this.lists[listIndex].isIndexInRange(i)) {\n                this.lists[listIndex].roomIndexToRoomId[i] =\n                    this.lists[listIndex].roomIndexToRoomId[\n                        i - 1\n                    ];\n            }\n        }\n    }\n\n    private shiftLeft(listIndex: number, hi: number, low: number) {\n        //     l   h\n        // 0,1,2,3,4 <- before\n        // 0,1,3,4,4 <- after, low is deleted and hi is duplicated\n        for (let i = low; i < hi; i++) {\n            if (this.lists[listIndex].isIndexInRange(i)) {\n                this.lists[listIndex].roomIndexToRoomId[i] =\n                    this.lists[listIndex].roomIndexToRoomId[\n                        i + 1\n                    ];\n            }\n        }\n    }\n\n    private removeEntry(listIndex: number, index: number) {\n        // work out the max index\n        let max = -1;\n        for (const n in this.lists[listIndex].roomIndexToRoomId) {\n            if (Number(n) > max) {\n                max = Number(n);\n            }\n        }\n        if (max < 0 || index > max) {\n            return;\n        }\n        // Everything higher than the gap needs to be shifted left.\n        this.shiftLeft(listIndex, max, index);\n        delete this.lists[listIndex].roomIndexToRoomId[max];\n    }\n\n    private addEntry(listIndex: number, index: number) {\n        // work out the max index\n        let max = -1;\n        for (const n in this.lists[listIndex].roomIndexToRoomId) {\n            if (Number(n) > max) {\n                max = Number(n);\n            }\n        }\n        if (max < 0 || index > max) {\n            return;\n        }\n        // Everything higher than the gap needs to be shifted right, +1 so we don't delete the highest element\n        this.shiftRight(listIndex, max+1, index);\n    }\n\n    private processListOps(list: ListResponse, listIndex: number): void {\n        let gapIndex = -1;\n        list.ops.forEach((op: Operation) => {\n            switch (op.op) {\n                case \"DELETE\": {\n                    logger.debug(\"DELETE\", listIndex, op.index, \";\");\n                    delete this.lists[listIndex].roomIndexToRoomId[op.index];\n                    if (gapIndex !== -1) {\n                        // we already have a DELETE operation to process, so process it.\n                        this.removeEntry(listIndex, gapIndex);\n                    }\n                    gapIndex = op.index;\n                    break;\n                }\n                case \"INSERT\": {\n                    logger.debug(\n                        \"INSERT\",\n                        listIndex,\n                        op.index,\n                        op.room_id,\n                        \";\",\n                    );\n                    if (this.lists[listIndex].roomIndexToRoomId[op.index]) {\n                        // something is in this space, shift items out of the way\n                        if (gapIndex < 0) {\n                            // we haven't been told where to shift from, so make way for a new room entry.\n                            this.addEntry(listIndex, op.index);\n                        } else if (gapIndex > op.index) {\n                            // the gap is further down the list, shift every element to the right\n                            // starting at the gap so we can just shift each element in turn:\n                            // [A,B,C,_] gapIndex=3, op.index=0\n                            // [A,B,C,C] i=3\n                            // [A,B,B,C] i=2\n                            // [A,A,B,C] i=1\n                            // Terminate. We'll assign into op.index next.\n                            this.shiftRight(listIndex, gapIndex, op.index);\n                        } else if (gapIndex < op.index) {\n                            // the gap is further up the list, shift every element to the left\n                            // starting at the gap so we can just shift each element in turn\n                            this.shiftLeft(listIndex, op.index, gapIndex);\n                        }\n                        gapIndex = -1; // forget the gap, we don't need it anymore.\n                    }\n                    this.lists[listIndex].roomIndexToRoomId[op.index] = op.room_id;\n                    break;\n                }\n                case \"INVALIDATE\": {\n                    const startIndex = op.range[0];\n                    for (let i = startIndex; i <= op.range[1]; i++) {\n                        delete this.lists[listIndex].roomIndexToRoomId[i];\n                    }\n                    logger.debug(\n                        \"INVALIDATE\",\n                        listIndex,\n                        op.range[0],\n                        op.range[1],\n                        \";\",\n                    );\n                    break;\n                }\n                case \"SYNC\": {\n                    const startIndex = op.range[0];\n                    for (let i = startIndex; i <= op.range[1]; i++) {\n                        const roomId = op.room_ids[i - startIndex];\n                        if (!roomId) {\n                            break; // we are at the end of list\n                        }\n                        this.lists[listIndex].roomIndexToRoomId[i] = roomId;\n                    }\n                    logger.debug(\n                        \"SYNC\",\n                        listIndex,\n                        op.range[0],\n                        op.range[1],\n                        (op.room_ids || []).join(\" \"),\n                        \";\",\n                    );\n                    break;\n                }\n            }\n        });\n        if (gapIndex !== -1) {\n            // we already have a DELETE operation to process, so process it\n            // Everything higher than the gap needs to be shifted left.\n            this.removeEntry(listIndex, gapIndex);\n        }\n    }\n\n    /**\n     * Resend a Sliding Sync request. Used when something has changed in the request. Resolves with\n     * the transaction ID of this request on success. Rejects with the transaction ID of this request\n     * on failure.\n     */\n    public resend(): Promise<string> {\n        if (this.needsResend && this.txnIdDefers.length > 0) {\n            // we already have a resend queued, so just return the same promise\n            return this.txnIdDefers[this.txnIdDefers.length-1].promise;\n        }\n        this.needsResend = true;\n        this.txnId = this.client.makeTxnId();\n        const d = defer<string>();\n        this.txnIdDefers.push({\n            ...d,\n            txnId: this.txnId,\n        });\n        this.pendingReq?.abort();\n        return d.promise;\n    }\n\n    private resolveTransactionDefers(txnId?: string) {\n        if (!txnId) {\n            return;\n        }\n        // find the matching index\n        let txnIndex = -1;\n        for (let i = 0; i < this.txnIdDefers.length; i++) {\n            if (this.txnIdDefers[i].txnId === txnId) {\n                txnIndex = i;\n                break;\n            }\n        }\n        if (txnIndex === -1) {\n            // this shouldn't happen; we shouldn't be seeing txn_ids for things we don't know about,\n            // whine about it.\n            logger.warn(`resolveTransactionDefers: seen ${txnId} but it isn't a pending txn, ignoring.`);\n            return;\n        }\n        // This list is sorted in time, so if the input txnId ACKs in the middle of this array,\n        // then everything before it that hasn't been ACKed yet never will and we should reject them.\n        for (let i = 0; i < txnIndex; i++) {\n            this.txnIdDefers[i].reject(this.txnIdDefers[i].txnId);\n        }\n        this.txnIdDefers[txnIndex].resolve(txnId);\n        // clear out settled promises, incuding the one we resolved.\n        this.txnIdDefers = this.txnIdDefers.slice(txnIndex+1);\n    }\n\n    /**\n     * Stop syncing with the server.\n     */\n    public stop(): void {\n        this.terminated = true;\n        this.pendingReq?.abort();\n        // remove all listeners so things can be GC'd\n        this.removeAllListeners(SlidingSyncEvent.Lifecycle);\n        this.removeAllListeners(SlidingSyncEvent.List);\n        this.removeAllListeners(SlidingSyncEvent.RoomData);\n    }\n\n    /**\n     * Start syncing with the server. Blocks until stopped.\n     */\n    public async start() {\n        let currentPos: string;\n        while (!this.terminated) {\n            this.needsResend = false;\n            let doNotUpdateList = false;\n            let resp: MSC3575SlidingSyncResponse;\n            try {\n                const listModifiedCount = this.listModifiedCount;\n                const reqBody: MSC3575SlidingSyncRequest = {\n                    lists: this.lists.map((l) => {\n                        return l.getList(false);\n                    }),\n                    pos: currentPos,\n                    timeout: this.timeoutMS,\n                    clientTimeout: this.timeoutMS + BUFFER_PERIOD_MS,\n                    extensions: this.getExtensionRequest(currentPos === undefined),\n                };\n                // check if we are (un)subscribing to a room and modify request this one time for it\n                const newSubscriptions = difference(this.desiredRoomSubscriptions, this.confirmedRoomSubscriptions);\n                const unsubscriptions = difference(this.confirmedRoomSubscriptions, this.desiredRoomSubscriptions);\n                if (unsubscriptions.size > 0) {\n                    reqBody.unsubscribe_rooms = Array.from(unsubscriptions);\n                }\n                if (newSubscriptions.size > 0) {\n                    reqBody.room_subscriptions = {};\n                    for (const roomId of newSubscriptions) {\n                        reqBody.room_subscriptions[roomId] = this.roomSubscriptionInfo;\n                    }\n                }\n                if (this.txnId) {\n                    reqBody.txn_id = this.txnId;\n                    this.txnId = null;\n                }\n                this.pendingReq = this.client.slidingSync(reqBody, this.proxyBaseUrl);\n                resp = await this.pendingReq;\n                logger.debug(resp);\n                currentPos = resp.pos;\n                // update what we think we're subscribed to.\n                for (const roomId of newSubscriptions) {\n                    this.confirmedRoomSubscriptions.add(roomId);\n                }\n                for (const roomId of unsubscriptions) {\n                    this.confirmedRoomSubscriptions.delete(roomId);\n                }\n                if (listModifiedCount !== this.listModifiedCount) {\n                    // the lists have been modified whilst we were waiting for 'await' to return, but the abort()\n                    // call did nothing. It is NOT SAFE to modify the list array now. We'll process the response but\n                    // not update list pointers.\n                    logger.debug(\"list modified during await call, not updating list\");\n                    doNotUpdateList = true;\n                }\n                // mark all these lists as having been sent as sticky so we don't keep sending sticky params\n                this.lists.forEach((l) => {\n                    l.setModified(false);\n                });\n                // set default empty values so we don't need to null check\n                resp.lists = resp.lists || [];\n                resp.rooms = resp.rooms || {};\n                resp.extensions = resp.extensions || {};\n                resp.lists.forEach((val, i) => {\n                    this.lists[i].joinedCount = val.count;\n                });\n                this.invokeLifecycleListeners(\n                    SlidingSyncState.RequestFinished,\n                    resp,\n                );\n            } catch (err) {\n                if (err.httpStatus) {\n                    this.invokeLifecycleListeners(\n                        SlidingSyncState.RequestFinished,\n                        null,\n                        err,\n                    );\n                    await sleep(3000);\n                } else if (this.needsResend || err === \"aborted\") {\n                    // don't sleep as we caused this error by abort()ing the request.\n                    // we check for 'aborted' because that's the error Jest returns and without it\n                    // we get warnings about not exiting fast enough.\n                    continue;\n                } else {\n                    logger.error(err);\n                    await sleep(3000);\n                }\n            }\n            if (!resp) {\n                continue;\n            }\n            this.onPreExtensionsResponse(resp.extensions);\n\n            Object.keys(resp.rooms).forEach((roomId) => {\n                this.invokeRoomDataListeners(\n                    roomId,\n                    resp.rooms[roomId],\n                );\n            });\n\n            const listIndexesWithUpdates: Set<number> = new Set();\n            if (!doNotUpdateList) {\n                resp.lists.forEach((list, listIndex) => {\n                    list.ops = list.ops || [];\n                    if (list.ops.length > 0) {\n                        listIndexesWithUpdates.add(listIndex);\n                    }\n                    this.processListOps(list, listIndex);\n                });\n            }\n            this.invokeLifecycleListeners(SlidingSyncState.Complete, resp);\n            this.onPostExtensionsResponse(resp.extensions);\n            listIndexesWithUpdates.forEach((i) => {\n                this.emit(\n                    SlidingSyncEvent.List,\n                    i, this.lists[i].joinedCount, Object.assign({}, this.lists[i].roomIndexToRoomId),\n                );\n            });\n\n            this.resolveTransactionDefers(resp.txn_id);\n        }\n    }\n}\n\nconst difference = (setA: Set<string>, setB: Set<string>): Set<string> => {\n    const diff = new Set(setA);\n    for (const elem of setB) {\n        diff.delete(elem);\n    }\n    return diff;\n};\n"],"mappings":"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"}