{"version":3,"file":"OutgoingRoomKeyRequestManager.js","names":["SEND_KEY_REQUESTS_DELAY_MS","RoomKeyRequestState","OutgoingRoomKeyRequestManager","constructor","baseApis","deviceId","cryptoStore","start","clientRunning","stop","logger","log","sendQueuedRequests","startTimer","queueRoomKeyRequest","requestBody","recipients","resend","req","getOutgoingRoomKeyRequest","getOrAddOutgoingRoomKeyRequest","requestId","makeTxnId","state","Unsent","CancellationPendingAndWillResend","CancellationPending","Sent","updateOutgoingRoomKeyRequest","cancellationTxnId","updatedReq","requestTxnId","sendOutgoingRoomKeyRequestCancellation","e","error","Error","cancelRoomKeyRequest","then","stringifyRequestBody","deleteOutgoingRoomKeyRequest","catch","getOutgoingSentRoomKeyRequest","userId","getOutgoingRoomKeyRequestsByTarget","cancelAndResendAllOutgoingRequests","outgoings","getAllOutgoingRoomKeyRequestsByState","Promise","all","map","sendOutgoingRoomKeyRequestsTimer","startSendingOutgoingRoomKeyRequests","sendOutgoingRoomKeyRequestsRunning","sendOutgoingRoomKeyRequests","finally","warn","setTimeout","resolve","getOutgoingRoomKeyRequestByState","prom","sendOutgoingRoomKeyRequest","stringifyRecipientList","requestMessage","action","requesting_device_id","request_id","body","sendMessageToDevices","andResend","message","txnId","contentMap","recip","sendToDevice","EventType","RoomKeyRequest","room_id","session_id","r","join"],"sources":["../../src/crypto/OutgoingRoomKeyRequestManager.ts"],"sourcesContent":["/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { logger } from '../logger';\nimport { MatrixClient } from \"../client\";\nimport { IRoomKeyRequestBody, IRoomKeyRequestRecipient } from \"./index\";\nimport { CryptoStore, OutgoingRoomKeyRequest } from './store/base';\nimport { EventType } from \"../@types/event\";\n\n/**\n * Internal module. Management of outgoing room key requests.\n *\n * See https://docs.google.com/document/d/1m4gQkcnJkxNuBmb5NoFCIadIY-DyqqNAS3lloE73BlQ\n * for draft documentation on what we're supposed to be implementing here.\n *\n * @module\n */\n\n// delay between deciding we want some keys, and sending out the request, to\n// allow for (a) it turning up anyway, (b) grouping requests together\nconst SEND_KEY_REQUESTS_DELAY_MS = 500;\n\n/** possible states for a room key request\n *\n * The state machine looks like:\n *\n *     |         (cancellation sent)\n *     | .-------------------------------------------------.\n *     | |                                                 |\n *     V V       (cancellation requested)                  |\n *   UNSENT  -----------------------------+                |\n *     |                                  |                |\n *     |                                  |                |\n *     | (send successful)                |  CANCELLATION_PENDING_AND_WILL_RESEND\n *     V                                  |                Î›\n *    SENT                                |                |\n *     |--------------------------------  |  --------------'\n *     |                                  |  (cancellation requested with intent\n *     |                                  |   to resend the original request)\n *     |                                  |\n *     | (cancellation requested)         |\n *     V                                  |\n * CANCELLATION_PENDING                   |\n *     |                                  |\n *     | (cancellation sent)              |\n *     V                                  |\n * (deleted)  <---------------------------+\n *\n * @enum {number}\n */\nexport enum RoomKeyRequestState {\n    /** request not yet sent */\n    Unsent,\n    /** request sent, awaiting reply */\n    Sent,\n    /** reply received, cancellation not yet sent */\n    CancellationPending,\n    /**\n     * Cancellation not yet sent and will transition to UNSENT instead of\n     * being deleted once the cancellation has been sent.\n     */\n    CancellationPendingAndWillResend,\n}\n\nexport class OutgoingRoomKeyRequestManager {\n    // handle for the delayed call to sendOutgoingRoomKeyRequests. Non-null\n    // if the callback has been set, or if it is still running.\n    private sendOutgoingRoomKeyRequestsTimer: ReturnType<typeof setTimeout> = null;\n\n    // sanity check to ensure that we don't end up with two concurrent runs\n    // of sendOutgoingRoomKeyRequests\n    private sendOutgoingRoomKeyRequestsRunning = false;\n\n    private clientRunning = false;\n\n    constructor(\n        private readonly baseApis: MatrixClient,\n        private readonly deviceId: string,\n        private readonly cryptoStore: CryptoStore,\n    ) {}\n\n    /**\n     * Called when the client is started. Sets background processes running.\n     */\n    public start(): void {\n        this.clientRunning = true;\n    }\n\n    /**\n     * Called when the client is stopped. Stops any running background processes.\n     */\n    public stop(): void {\n        logger.log('stopping OutgoingRoomKeyRequestManager');\n        // stop the timer on the next run\n        this.clientRunning = false;\n    }\n\n    /**\n     * Send any requests that have been queued\n     */\n    public sendQueuedRequests(): void {\n        this.startTimer();\n    }\n\n    /**\n     * Queue up a room key request, if we haven't already queued or sent one.\n     *\n     * The `requestBody` is compared (with a deep-equality check) against\n     * previous queued or sent requests and if it matches, no change is made.\n     * Otherwise, a request is added to the pending list, and a job is started\n     * in the background to send it.\n     *\n     * @param {module:crypto~RoomKeyRequestBody} requestBody\n     * @param {Array<{userId: string, deviceId: string}>} recipients\n     * @param {boolean} resend whether to resend the key request if there is\n     *    already one\n     *\n     * @returns {Promise} resolves when the request has been added to the\n     *    pending list (or we have established that a similar request already\n     *    exists)\n     */\n    public async queueRoomKeyRequest(\n        requestBody: IRoomKeyRequestBody,\n        recipients: IRoomKeyRequestRecipient[],\n        resend = false,\n    ): Promise<void> {\n        const req = await this.cryptoStore.getOutgoingRoomKeyRequest(requestBody);\n        if (!req) {\n            await this.cryptoStore.getOrAddOutgoingRoomKeyRequest({\n                requestBody: requestBody,\n                recipients: recipients,\n                requestId: this.baseApis.makeTxnId(),\n                state: RoomKeyRequestState.Unsent,\n            });\n        } else {\n            switch (req.state) {\n                case RoomKeyRequestState.CancellationPendingAndWillResend:\n                case RoomKeyRequestState.Unsent:\n                    // nothing to do here, since we're going to send a request anyways\n                    return;\n\n                case RoomKeyRequestState.CancellationPending: {\n                    // existing request is about to be cancelled.  If we want to\n                    // resend, then change the state so that it resends after\n                    // cancelling.  Otherwise, just cancel the cancellation.\n                    const state = resend ?\n                        RoomKeyRequestState.CancellationPendingAndWillResend :\n                        RoomKeyRequestState.Sent;\n                    await this.cryptoStore.updateOutgoingRoomKeyRequest(\n                        req.requestId, RoomKeyRequestState.CancellationPending, {\n                            state,\n                            cancellationTxnId: this.baseApis.makeTxnId(),\n                        },\n                    );\n                    break;\n                }\n                case RoomKeyRequestState.Sent: {\n                    // a request has already been sent.  If we don't want to\n                    // resend, then do nothing.  If we do want to, then cancel the\n                    // existing request and send a new one.\n                    if (resend) {\n                        const state =\n                              RoomKeyRequestState.CancellationPendingAndWillResend;\n                        const updatedReq =\n                              await this.cryptoStore.updateOutgoingRoomKeyRequest(\n                                  req.requestId, RoomKeyRequestState.Sent, {\n                                      state,\n                                      cancellationTxnId: this.baseApis.makeTxnId(),\n                                      // need to use a new transaction ID so that\n                                      // the request gets sent\n                                      requestTxnId: this.baseApis.makeTxnId(),\n                                  },\n                              );\n                        if (!updatedReq) {\n                            // updateOutgoingRoomKeyRequest couldn't find the request\n                            // in state ROOM_KEY_REQUEST_STATES.SENT, so we must have\n                            // raced with another tab to mark the request cancelled.\n                            // Try again, to make sure the request is resent.\n                            return this.queueRoomKeyRequest(requestBody, recipients, resend);\n                        }\n\n                        // We don't want to wait for the timer, so we send it\n                        // immediately. (We might actually end up racing with the timer,\n                        // but that's ok: even if we make the request twice, we'll do it\n                        // with the same transaction_id, so only one message will get\n                        // sent).\n                        //\n                        // (We also don't want to wait for the response from the server\n                        // here, as it will slow down processing of received keys if we\n                        // do.)\n                        try {\n                            await this.sendOutgoingRoomKeyRequestCancellation(\n                                updatedReq,\n                                true,\n                            );\n                        } catch (e) {\n                            logger.error(\n                                \"Error sending room key request cancellation;\"\n                                    + \" will retry later.\", e,\n                            );\n                        }\n                        // The request has transitioned from\n                        // CANCELLATION_PENDING_AND_WILL_RESEND to UNSENT. We\n                        // still need to resend the request which is now UNSENT, so\n                        // start the timer if it isn't already started.\n                    }\n                    break;\n                }\n                default:\n                    throw new Error('unhandled state: ' + req.state);\n            }\n        }\n    }\n\n    /**\n     * Cancel room key requests, if any match the given requestBody\n     *\n     * @param {module:crypto~RoomKeyRequestBody} requestBody\n     *\n     * @returns {Promise} resolves when the request has been updated in our\n     *    pending list.\n     */\n    public cancelRoomKeyRequest(requestBody: IRoomKeyRequestBody): Promise<unknown> {\n        return this.cryptoStore.getOutgoingRoomKeyRequest(\n            requestBody,\n        ).then((req): unknown => {\n            if (!req) {\n                // no request was made for this key\n                return;\n            }\n            switch (req.state) {\n                case RoomKeyRequestState.CancellationPending:\n                case RoomKeyRequestState.CancellationPendingAndWillResend:\n                    // nothing to do here\n                    return;\n\n                case RoomKeyRequestState.Unsent:\n                    // just delete it\n\n                    // FIXME: ghahah we may have attempted to send it, and\n                    // not yet got a successful response. So the server\n                    // may have seen it, so we still need to send a cancellation\n                    // in that case :/\n\n                    logger.log(\n                        'deleting unnecessary room key request for ' +\n                        stringifyRequestBody(requestBody),\n                    );\n                    return this.cryptoStore.deleteOutgoingRoomKeyRequest(req.requestId, RoomKeyRequestState.Unsent);\n\n                case RoomKeyRequestState.Sent: {\n                    // send a cancellation.\n                    return this.cryptoStore.updateOutgoingRoomKeyRequest(\n                        req.requestId, RoomKeyRequestState.Sent, {\n                            state: RoomKeyRequestState.CancellationPending,\n                            cancellationTxnId: this.baseApis.makeTxnId(),\n                        },\n                    ).then((updatedReq) => {\n                        if (!updatedReq) {\n                            // updateOutgoingRoomKeyRequest couldn't find the\n                            // request in state ROOM_KEY_REQUEST_STATES.SENT,\n                            // so we must have raced with another tab to mark\n                            // the request cancelled. There is no point in\n                            // sending another cancellation since the other tab\n                            // will do it.\n                            logger.log(\n                                'Tried to cancel room key request for ' +\n                                stringifyRequestBody(requestBody) +\n                                ' but it was already cancelled in another tab',\n                            );\n                            return;\n                        }\n\n                        // We don't want to wait for the timer, so we send it\n                        // immediately. (We might actually end up racing with the timer,\n                        // but that's ok: even if we make the request twice, we'll do it\n                        // with the same transaction_id, so only one message will get\n                        // sent).\n                        //\n                        // (We also don't want to wait for the response from the server\n                        // here, as it will slow down processing of received keys if we\n                        // do.)\n                        this.sendOutgoingRoomKeyRequestCancellation(\n                            updatedReq,\n                        ).catch((e) => {\n                            logger.error(\n                                \"Error sending room key request cancellation;\"\n                                + \" will retry later.\", e,\n                            );\n                            this.startTimer();\n                        });\n                    });\n                }\n                default:\n                    throw new Error('unhandled state: ' + req.state);\n            }\n        });\n    }\n\n    /**\n     * Look for room key requests by target device and state\n     *\n     * @param {string} userId Target user ID\n     * @param {string} deviceId Target device ID\n     *\n     * @return {Promise} resolves to a list of all the\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}\n     */\n    public getOutgoingSentRoomKeyRequest(userId: string, deviceId: string): Promise<OutgoingRoomKeyRequest[]> {\n        return this.cryptoStore.getOutgoingRoomKeyRequestsByTarget(userId, deviceId, [RoomKeyRequestState.Sent]);\n    }\n\n    /**\n     * Find anything in `sent` state, and kick it around the loop again.\n     * This is intended for situations where something substantial has changed, and we\n     * don't really expect the other end to even care about the cancellation.\n     * For example, after initialization or self-verification.\n     * @return {Promise} An array of `queueRoomKeyRequest` outputs.\n     */\n    public async cancelAndResendAllOutgoingRequests(): Promise<void[]> {\n        const outgoings = await this.cryptoStore.getAllOutgoingRoomKeyRequestsByState(RoomKeyRequestState.Sent);\n        return Promise.all(outgoings.map(({ requestBody, recipients }) =>\n            this.queueRoomKeyRequest(requestBody, recipients, true)));\n    }\n\n    // start the background timer to send queued requests, if the timer isn't\n    // already running\n    private startTimer(): void {\n        if (this.sendOutgoingRoomKeyRequestsTimer) {\n            return;\n        }\n\n        const startSendingOutgoingRoomKeyRequests = () => {\n            if (this.sendOutgoingRoomKeyRequestsRunning) {\n                throw new Error(\"RoomKeyRequestSend already in progress!\");\n            }\n            this.sendOutgoingRoomKeyRequestsRunning = true;\n\n            this.sendOutgoingRoomKeyRequests().finally(() => {\n                this.sendOutgoingRoomKeyRequestsRunning = false;\n            }).catch((e) => {\n                // this should only happen if there is an indexeddb error,\n                // in which case we're a bit stuffed anyway.\n                logger.warn(\n                    `error in OutgoingRoomKeyRequestManager: ${e}`,\n                );\n            });\n        };\n\n        this.sendOutgoingRoomKeyRequestsTimer = setTimeout(\n            startSendingOutgoingRoomKeyRequests,\n            SEND_KEY_REQUESTS_DELAY_MS,\n        );\n    }\n\n    // look for and send any queued requests. Runs itself recursively until\n    // there are no more requests, or there is an error (in which case, the\n    // timer will be restarted before the promise resolves).\n    private sendOutgoingRoomKeyRequests(): Promise<void> {\n        if (!this.clientRunning) {\n            this.sendOutgoingRoomKeyRequestsTimer = null;\n            return Promise.resolve();\n        }\n\n        return this.cryptoStore.getOutgoingRoomKeyRequestByState([\n            RoomKeyRequestState.CancellationPending,\n            RoomKeyRequestState.CancellationPendingAndWillResend,\n            RoomKeyRequestState.Unsent,\n        ]).then((req: OutgoingRoomKeyRequest) => {\n            if (!req) {\n                this.sendOutgoingRoomKeyRequestsTimer = null;\n                return;\n            }\n\n            let prom;\n            switch (req.state) {\n                case RoomKeyRequestState.Unsent:\n                    prom = this.sendOutgoingRoomKeyRequest(req);\n                    break;\n                case RoomKeyRequestState.CancellationPending:\n                    prom = this.sendOutgoingRoomKeyRequestCancellation(req);\n                    break;\n                case RoomKeyRequestState.CancellationPendingAndWillResend:\n                    prom = this.sendOutgoingRoomKeyRequestCancellation(req, true);\n                    break;\n            }\n\n            return prom.then(() => {\n                // go around the loop again\n                return this.sendOutgoingRoomKeyRequests();\n            }).catch((e) => {\n                logger.error(\"Error sending room key request; will retry later.\", e);\n                this.sendOutgoingRoomKeyRequestsTimer = null;\n            });\n        });\n    }\n\n    // given a RoomKeyRequest, send it and update the request record\n    private sendOutgoingRoomKeyRequest(req: OutgoingRoomKeyRequest): Promise<unknown> {\n        logger.log(\n            `Requesting keys for ${stringifyRequestBody(req.requestBody)}` +\n            ` from ${stringifyRecipientList(req.recipients)}` +\n            `(id ${req.requestId})`,\n        );\n\n        const requestMessage = {\n            action: \"request\",\n            requesting_device_id: this.deviceId,\n            request_id: req.requestId,\n            body: req.requestBody,\n        };\n\n        return this.sendMessageToDevices(\n            requestMessage, req.recipients, req.requestTxnId || req.requestId,\n        ).then(() => {\n            return this.cryptoStore.updateOutgoingRoomKeyRequest(\n                req.requestId, RoomKeyRequestState.Unsent,\n                { state: RoomKeyRequestState.Sent },\n            );\n        });\n    }\n\n    // Given a RoomKeyRequest, cancel it and delete the request record unless\n    // andResend is set, in which case transition to UNSENT.\n    private sendOutgoingRoomKeyRequestCancellation(req: OutgoingRoomKeyRequest, andResend = false): Promise<unknown> {\n        logger.log(\n            `Sending cancellation for key request for ` +\n            `${stringifyRequestBody(req.requestBody)} to ` +\n            `${stringifyRecipientList(req.recipients)} ` +\n            `(cancellation id ${req.cancellationTxnId})`,\n        );\n\n        const requestMessage = {\n            action: \"request_cancellation\",\n            requesting_device_id: this.deviceId,\n            request_id: req.requestId,\n        };\n\n        return this.sendMessageToDevices(\n            requestMessage, req.recipients, req.cancellationTxnId,\n        ).then(() => {\n            if (andResend) {\n                // We want to resend, so transition to UNSENT\n                return this.cryptoStore.updateOutgoingRoomKeyRequest(\n                    req.requestId,\n                    RoomKeyRequestState.CancellationPendingAndWillResend,\n                    { state: RoomKeyRequestState.Unsent },\n                );\n            }\n            return this.cryptoStore.deleteOutgoingRoomKeyRequest(\n                req.requestId, RoomKeyRequestState.CancellationPending,\n            );\n        });\n    }\n\n    // send a RoomKeyRequest to a list of recipients\n    private sendMessageToDevices(message, recipients, txnId: string): Promise<{}> {\n        const contentMap: Record<string, Record<string, Record<string, any>>> = {};\n        for (const recip of recipients) {\n            if (!contentMap[recip.userId]) {\n                contentMap[recip.userId] = {};\n            }\n            contentMap[recip.userId][recip.deviceId] = message;\n        }\n\n        return this.baseApis.sendToDevice(EventType.RoomKeyRequest, contentMap, txnId);\n    }\n}\n\nfunction stringifyRequestBody(requestBody) {\n    // we assume that the request is for megolm keys, which are identified by\n    // room id and session id\n    return requestBody.room_id + \" / \" + requestBody.session_id;\n}\n\nfunction stringifyRecipientList(recipients) {\n    return '['\n        + recipients.map((r) => `${r.userId}:${r.deviceId}`).join(\",\")\n        + ']';\n}\n\n"],"mappings":"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"}