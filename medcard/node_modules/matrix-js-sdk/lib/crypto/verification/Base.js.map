{"version":3,"file":"Base.js","names":["timeoutException","Error","SwitchStartEventError","constructor","startEvent","VerificationEvent","VerificationBase","TypedEventEmitter","channel","baseApis","userId","deviceId","request","initiatedByMe","sender","getSender","content","getContent","getUserId","from_device","getDeviceId","hasBeenCancelled","cancelled","resetTimer","logger","info","transactionTimeoutTimer","clearTimeout","setTimeout","_done","cancel","endTimer","send","type","uncompletedContent","waitForEvent","Promise","reject","existingEvent","getEventFromOtherParty","resolve","expectedEvent","resolveEvent","rejectEvent","canSwitchStartEvent","event","switchStartEvent","log","restartingFlow","undefined","handleEvent","e","getType","reason","code","exception","done","onVerifierFinished","requestKeysDuringVerification","onVerifierCancelled","timeoutEvent","newTimeoutError","MatrixEvent","body","toString","promise","emit","Cancel","verify","args","doVerification","started","crossSignId","crypto","deviceList","getStoredCrossSigningForUser","getId","then","bind","verifyKeys","keys","verifier","verifiedDevices","keyId","keyInfo","Object","entries","split","device","getStoredDevice","push","crossSigningInfo","DeviceInfo","fromStorage","warn","length","key","setDeviceVerification","credentials","checkKeyBackup","events"],"sources":["../../../src/crypto/verification/Base.ts"],"sourcesContent":["/*\nCopyright 2018 New Vector Ltd\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Base class for verification methods.\n * @module crypto/verification/Base\n */\n\nimport { MatrixEvent } from '../../models/event';\nimport { logger } from '../../logger';\nimport { DeviceInfo } from '../deviceinfo';\nimport { newTimeoutError } from \"./Error\";\nimport { KeysDuringVerification, requestKeysDuringVerification } from \"../CrossSigning\";\nimport { IVerificationChannel } from \"./request/Channel\";\nimport { MatrixClient } from \"../../client\";\nimport { VerificationRequest } from \"./request/VerificationRequest\";\nimport { ListenerMap, TypedEventEmitter } from \"../../models/typed-event-emitter\";\n\nconst timeoutException = new Error(\"Verification timed out\");\n\nexport class SwitchStartEventError extends Error {\n    constructor(public readonly startEvent: MatrixEvent) {\n        super();\n    }\n}\n\nexport type KeyVerifier = (keyId: string, device: DeviceInfo, keyInfo: string) => void;\n\nexport enum VerificationEvent {\n    Cancel = \"cancel\",\n}\n\nexport type VerificationEventHandlerMap = {\n    [VerificationEvent.Cancel]: (e: Error | MatrixEvent) => void;\n};\n\nexport class VerificationBase<\n    Events extends string,\n    Arguments extends ListenerMap<Events | VerificationEvent>,\n> extends TypedEventEmitter<Events | VerificationEvent, Arguments, VerificationEventHandlerMap> {\n    private cancelled = false;\n    private _done = false;\n    private promise: Promise<void> = null;\n    private transactionTimeoutTimer: ReturnType<typeof setTimeout> = null;\n    protected expectedEvent: string;\n    private resolve: () => void;\n    private reject: (e: Error | MatrixEvent) => void;\n    private resolveEvent: (e: MatrixEvent) => void;\n    private rejectEvent: (e: Error) => void;\n    private started: boolean;\n\n    /**\n     * Base class for verification methods.\n     *\n     * <p>Once a verifier object is created, the verification can be started by\n     * calling the verify() method, which will return a promise that will\n     * resolve when the verification is completed, or reject if it could not\n     * complete.</p>\n     *\n     * <p>Subclasses must have a NAME class property.</p>\n     *\n     * @class\n     *\n     * @param {Object} channel the verification channel to send verification messages over.\n     * TODO: Channel types\n     *\n     * @param {MatrixClient} baseApis base matrix api interface\n     *\n     * @param {string} userId the user ID that is being verified\n     *\n     * @param {string} deviceId the device ID that is being verified\n     *\n     * @param {object} [startEvent] the m.key.verification.start event that\n     * initiated this verification, if any\n     *\n     * @param {object} [request] the key verification request object related to\n     * this verification, if any\n     */\n    constructor(\n        public readonly channel: IVerificationChannel,\n        public readonly baseApis: MatrixClient,\n        public readonly userId: string,\n        public readonly deviceId: string,\n        public startEvent: MatrixEvent,\n        public readonly request: VerificationRequest,\n    ) {\n        super();\n    }\n\n    public get initiatedByMe(): boolean {\n        // if there is no start event yet,\n        // we probably want to send it,\n        // which happens if we initiate\n        if (!this.startEvent) {\n            return true;\n        }\n        const sender = this.startEvent.getSender();\n        const content = this.startEvent.getContent();\n        return sender === this.baseApis.getUserId() &&\n            content.from_device === this.baseApis.getDeviceId();\n    }\n\n    public get hasBeenCancelled(): boolean {\n        return this.cancelled;\n    }\n\n    private resetTimer(): void {\n        logger.info(\"Refreshing/starting the verification transaction timeout timer\");\n        if (this.transactionTimeoutTimer !== null) {\n            clearTimeout(this.transactionTimeoutTimer);\n        }\n        this.transactionTimeoutTimer = setTimeout(() => {\n            if (!this._done && !this.cancelled) {\n                logger.info(\"Triggering verification timeout\");\n                this.cancel(timeoutException);\n            }\n        }, 10 * 60 * 1000); // 10 minutes\n    }\n\n    private endTimer(): void {\n        if (this.transactionTimeoutTimer !== null) {\n            clearTimeout(this.transactionTimeoutTimer);\n            this.transactionTimeoutTimer = null;\n        }\n    }\n\n    protected send(type: string, uncompletedContent: Record<string, any>): Promise<void> {\n        return this.channel.send(type, uncompletedContent);\n    }\n\n    protected waitForEvent(type: string): Promise<MatrixEvent> {\n        if (this._done) {\n            return Promise.reject(new Error(\"Verification is already done\"));\n        }\n        const existingEvent = this.request.getEventFromOtherParty(type);\n        if (existingEvent) {\n            return Promise.resolve(existingEvent);\n        }\n\n        this.expectedEvent = type;\n        return new Promise((resolve, reject) => {\n            this.resolveEvent = resolve;\n            this.rejectEvent = reject;\n        });\n    }\n\n    public canSwitchStartEvent(event: MatrixEvent): boolean {\n        return false;\n    }\n\n    public switchStartEvent(event: MatrixEvent): void {\n        if (this.canSwitchStartEvent(event)) {\n            logger.log(\"Verification Base: switching verification start event\",\n                { restartingFlow: !!this.rejectEvent });\n            if (this.rejectEvent) {\n                const reject = this.rejectEvent;\n                this.rejectEvent = undefined;\n                reject(new SwitchStartEventError(event));\n            } else {\n                this.startEvent = event;\n            }\n        }\n    }\n\n    public handleEvent(e: MatrixEvent): void {\n        if (this._done) {\n            return;\n        } else if (e.getType() === this.expectedEvent) {\n            // if we receive an expected m.key.verification.done, then just\n            // ignore it, since we don't need to do anything about it\n            if (this.expectedEvent !== \"m.key.verification.done\") {\n                this.expectedEvent = undefined;\n                this.rejectEvent = undefined;\n                this.resetTimer();\n                this.resolveEvent(e);\n            }\n        } else if (e.getType() === \"m.key.verification.cancel\") {\n            const reject = this.reject;\n            this.reject = undefined;\n            // there is only promise to reject if verify has been called\n            if (reject) {\n                const content = e.getContent();\n                const { reason, code } = content;\n                reject(new Error(`Other side cancelled verification ` +\n                    `because ${reason} (${code})`));\n            }\n        } else if (this.expectedEvent) {\n            // only cancel if there is an event expected.\n            // if there is no event expected, it means verify() wasn't called\n            // and we're just replaying the timeline events when syncing\n            // after a refresh when the events haven't been stored in the cache yet.\n            const exception = new Error(\n                \"Unexpected message: expecting \" + this.expectedEvent\n                    + \" but got \" + e.getType(),\n            );\n            this.expectedEvent = undefined;\n            if (this.rejectEvent) {\n                const reject = this.rejectEvent;\n                this.rejectEvent = undefined;\n                reject(exception);\n            }\n            this.cancel(exception);\n        }\n    }\n\n    public done(): Promise<KeysDuringVerification | void> {\n        this.endTimer(); // always kill the activity timer\n        if (!this._done) {\n            this.request.onVerifierFinished();\n            this.resolve();\n            return requestKeysDuringVerification(this.baseApis, this.userId, this.deviceId);\n        }\n    }\n\n    public cancel(e: Error | MatrixEvent): void {\n        this.endTimer(); // always kill the activity timer\n        if (!this._done) {\n            this.cancelled = true;\n            this.request.onVerifierCancelled();\n            if (this.userId && this.deviceId) {\n                // send a cancellation to the other user (if it wasn't\n                // cancelled by the other user)\n                if (e === timeoutException) {\n                    const timeoutEvent = newTimeoutError();\n                    this.send(timeoutEvent.getType(), timeoutEvent.getContent());\n                } else if (e instanceof MatrixEvent) {\n                    const sender = e.getSender();\n                    if (sender !== this.userId) {\n                        const content = e.getContent();\n                        if (e.getType() === \"m.key.verification.cancel\") {\n                            content.code = content.code || \"m.unknown\";\n                            content.reason = content.reason || content.body\n                                || \"Unknown reason\";\n                            this.send(\"m.key.verification.cancel\", content);\n                        } else {\n                            this.send(\"m.key.verification.cancel\", {\n                                code: \"m.unknown\",\n                                reason: content.body || \"Unknown reason\",\n                            });\n                        }\n                    }\n                } else {\n                    this.send(\"m.key.verification.cancel\", {\n                        code: \"m.unknown\",\n                        reason: e.toString(),\n                    });\n                }\n            }\n            if (this.promise !== null) {\n                // when we cancel without a promise, we end up with a promise\n                // but no reject function. If cancel is called again, we'd error.\n                if (this.reject) this.reject(e);\n            } else {\n                // FIXME: this causes an \"Uncaught promise\" console message\n                // if nothing ends up chaining this promise.\n                this.promise = Promise.reject(e);\n            }\n            // Also emit a 'cancel' event that the app can listen for to detect cancellation\n            // before calling verify()\n            this.emit(VerificationEvent.Cancel, e);\n        }\n    }\n\n    /**\n     * Begin the key verification\n     *\n     * @returns {Promise} Promise which resolves when the verification has\n     *     completed.\n     */\n    public verify(): Promise<void> {\n        if (this.promise) return this.promise;\n\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = (...args) => {\n                this._done = true;\n                this.endTimer();\n                resolve(...args);\n            };\n            this.reject = (e: Error) => {\n                this._done = true;\n                this.endTimer();\n                reject(e);\n            };\n        });\n        if (this.doVerification && !this.started) {\n            this.started = true;\n            this.resetTimer(); // restart the timeout\n            new Promise<void>((resolve, reject) => {\n                const crossSignId = this.baseApis.crypto.deviceList.getStoredCrossSigningForUser(this.userId)?.getId();\n                if (crossSignId === this.deviceId) {\n                    reject(new Error(\"Device ID is the same as the cross-signing ID\"));\n                }\n                resolve();\n            }).then(() => this.doVerification()).then(this.done.bind(this), this.cancel.bind(this));\n        }\n        return this.promise;\n    }\n\n    protected doVerification?: () => Promise<void>;\n\n    protected async verifyKeys(userId: string, keys: Record<string, string>, verifier: KeyVerifier): Promise<void> {\n        // we try to verify all the keys that we're told about, but we might\n        // not know about all of them, so keep track of the keys that we know\n        // about, and ignore the rest\n        const verifiedDevices: [string, string, string][] = [];\n\n        for (const [keyId, keyInfo] of Object.entries(keys)) {\n            const deviceId = keyId.split(':', 2)[1];\n            const device = this.baseApis.getStoredDevice(userId, deviceId);\n            if (device) {\n                verifier(keyId, device, keyInfo);\n                verifiedDevices.push([deviceId, keyId, device.keys[keyId]]);\n            } else {\n                const crossSigningInfo = this.baseApis.crypto.deviceList.getStoredCrossSigningForUser(userId);\n                if (crossSigningInfo && crossSigningInfo.getId() === deviceId) {\n                    verifier(keyId, DeviceInfo.fromStorage({\n                        keys: {\n                            [keyId]: deviceId,\n                        },\n                    }, deviceId), keyInfo);\n                    verifiedDevices.push([deviceId, keyId, deviceId]);\n                } else {\n                    logger.warn(\n                        `verification: Could not find device ${deviceId} to verify`,\n                    );\n                }\n            }\n        }\n\n        // if none of the keys could be verified, then error because the app\n        // should be informed about that\n        if (!verifiedDevices.length) {\n            throw new Error(\"No devices could be verified\");\n        }\n\n        logger.info(\n            \"Verification completed! Marking devices verified: \",\n            verifiedDevices,\n        );\n        // TODO: There should probably be a batch version of this, otherwise it's going\n        // to upload each signature in a separate API call which is silly because the\n        // API supports as many signatures as you like.\n        for (const [deviceId, keyId, key] of verifiedDevices) {\n            await this.baseApis.crypto.setDeviceVerification(userId, deviceId, true, null, null, { [keyId]: key });\n        }\n\n        // if one of the user's own devices is being marked as verified / unverified,\n        // check the key backup status, since whether or not we use this depends on\n        // whether it has a signature from a verified device\n        if (userId == this.baseApis.credentials.userId) {\n            await this.baseApis.checkKeyBackup();\n        }\n    }\n\n    public get events(): string[] | undefined {\n        return undefined;\n    }\n}\n"],"mappings":"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"}