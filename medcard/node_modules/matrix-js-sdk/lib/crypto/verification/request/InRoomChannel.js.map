{"version":3,"file":"InRoomChannel.js","names":["MESSAGE_TYPE","EventType","RoomMessage","M_REFERENCE","M_RELATES_TO","InRoomChannel","constructor","client","roomId","userId","receiveStartFromOtherDevices","transactionId","requestEventId","getOtherPartyUserId","event","type","getEventType","REQUEST_TYPE","ownUserId","getUserId","sender","getSender","content","getContent","receiver","to","getTimestamp","getTs","canCreateRequest","getTransactionId","getId","relation","getRelation","rel_type","event_id","validateEvent","txnId","length","logger","log","VerificationRequest","getType","msgtype","handleEvent","request","isLiveEvent","hasEventId","getRoomId","isRemoteEcho","getUnsigned","transaction_id","isSentByUs","completedContentFromEvent","Object","assign","completeContent","READY_TYPE","START_TYPE","from_device","getDeviceId","body","methods","send","uncompletedContent","sendCompleted","sendType","response","sendEvent","InRoomRequests","Map","getRequest","getRequestByTxnId","getRequestByChannel","channel","requestsByTxnId","requestsByRoomId","get","setRequest","doSetRequest","setRequestByChannel","set","removeRequest","delete","size","findRequestInProgress","values","pending"],"sources":["../../../../src/crypto/verification/request/InRoomChannel.ts"],"sourcesContent":["/*\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n    VerificationRequest,\n    REQUEST_TYPE,\n    READY_TYPE,\n    START_TYPE,\n} from \"./VerificationRequest\";\nimport { logger } from '../../../logger';\nimport { IVerificationChannel } from \"./Channel\";\nimport { EventType } from \"../../../@types/event\";\nimport { MatrixClient } from \"../../../client\";\nimport { MatrixEvent } from \"../../../models/event\";\nimport { IRequestsMap } from \"../..\";\n\nconst MESSAGE_TYPE = EventType.RoomMessage;\nconst M_REFERENCE = \"m.reference\";\nconst M_RELATES_TO = \"m.relates_to\";\n\n/**\n * A key verification channel that sends verification events in the timeline of a room.\n * Uses the event id of the initial m.key.verification.request event as a transaction id.\n */\nexport class InRoomChannel implements IVerificationChannel {\n    private requestEventId: string = null;\n\n    /**\n     * @param {MatrixClient} client the matrix client, to send messages with and get current user & device from.\n     * @param {string} roomId id of the room where verification events should be posted in, should be a DM with the given user.\n     * @param {string} userId id of user that the verification request is directed at, should be present in the room.\n     */\n    constructor(\n        private readonly client: MatrixClient,\n        public readonly roomId: string,\n        public userId: string = null,\n    ) {\n    }\n\n    public get receiveStartFromOtherDevices(): boolean {\n        return true;\n    }\n\n    /** The transaction id generated/used by this verification channel */\n    public get transactionId(): string {\n        return this.requestEventId;\n    }\n\n    public static getOtherPartyUserId(event: MatrixEvent, client: MatrixClient): string {\n        const type = InRoomChannel.getEventType(event);\n        if (type !== REQUEST_TYPE) {\n            return;\n        }\n        const ownUserId = client.getUserId();\n        const sender = event.getSender();\n        const content = event.getContent();\n        const receiver = content.to;\n\n        if (sender === ownUserId) {\n            return receiver;\n        } else if (receiver === ownUserId) {\n            return sender;\n        }\n    }\n\n    /**\n     * @param {MatrixEvent} event the event to get the timestamp of\n     * @return {number} the timestamp when the event was sent\n     */\n    public getTimestamp(event: MatrixEvent): number {\n        return event.getTs();\n    }\n\n    /**\n     * Checks whether the given event type should be allowed to initiate a new VerificationRequest over this channel\n     * @param {string} type the event type to check\n     * @returns {boolean} boolean flag\n     */\n    public static canCreateRequest(type: string): boolean {\n        return type === REQUEST_TYPE;\n    }\n\n    public canCreateRequest(type: string): boolean {\n        return InRoomChannel.canCreateRequest(type);\n    }\n\n    /**\n     * Extract the transaction id used by a given key verification event, if any\n     * @param {MatrixEvent} event the event\n     * @returns {string} the transaction id\n     */\n    public static getTransactionId(event: MatrixEvent): string {\n        if (InRoomChannel.getEventType(event) === REQUEST_TYPE) {\n            return event.getId();\n        } else {\n            const relation = event.getRelation();\n            if (relation && relation.rel_type === M_REFERENCE) {\n                return relation.event_id;\n            }\n        }\n    }\n\n    /**\n     * Checks whether this event is a well-formed key verification event.\n     * This only does checks that don't rely on the current state of a potentially already channel\n     * so we can prevent channels being created by invalid events.\n     * `handleEvent` can do more checks and choose to ignore invalid events.\n     * @param {MatrixEvent} event the event to validate\n     * @param {MatrixClient} client the client to get the current user and device id from\n     * @returns {boolean} whether the event is valid and should be passed to handleEvent\n     */\n    public static validateEvent(event: MatrixEvent, client: MatrixClient): boolean {\n        const txnId = InRoomChannel.getTransactionId(event);\n        if (typeof txnId !== \"string\" || txnId.length === 0) {\n            return false;\n        }\n        const type = InRoomChannel.getEventType(event);\n        const content = event.getContent();\n\n        // from here on we're fairly sure that this is supposed to be\n        // part of a verification request, so be noisy when rejecting something\n        if (type === REQUEST_TYPE) {\n            if (!content || typeof content.to !== \"string\" || !content.to.length) {\n                logger.log(\"InRoomChannel: validateEvent: \" +\n                    \"no valid to \" + (content && content.to));\n                return false;\n            }\n\n            // ignore requests that are not direct to or sent by the syncing user\n            if (!InRoomChannel.getOtherPartyUserId(event, client)) {\n                logger.log(\"InRoomChannel: validateEvent: \" +\n                    `not directed to or sent by me: ${event.getSender()}` +\n                    `, ${content && content.to}`);\n                return false;\n            }\n        }\n\n        return VerificationRequest.validateEvent(type, event, client);\n    }\n\n    /**\n     * As m.key.verification.request events are as m.room.message events with the InRoomChannel\n     * to have a fallback message in non-supporting clients, we map the real event type\n     * to the symbolic one to keep things in unison with ToDeviceChannel\n     * @param {MatrixEvent} event the event to get the type of\n     * @returns {string} the \"symbolic\" event type\n     */\n    public static getEventType(event: MatrixEvent): string {\n        const type = event.getType();\n        if (type === MESSAGE_TYPE) {\n            const content = event.getContent();\n            if (content) {\n                const { msgtype } = content;\n                if (msgtype === REQUEST_TYPE) {\n                    return REQUEST_TYPE;\n                }\n            }\n        }\n        if (type && type !== REQUEST_TYPE) {\n            return type;\n        } else {\n            return \"\";\n        }\n    }\n\n    /**\n     * Changes the state of the channel, request, and verifier in response to a key verification event.\n     * @param {MatrixEvent} event to handle\n     * @param {VerificationRequest} request the request to forward handling to\n     * @param {boolean} isLiveEvent whether this is an even received through sync or not\n     * @returns {Promise} a promise that resolves when any requests as an answer to the passed-in event are sent.\n     */\n    public handleEvent(event: MatrixEvent, request: VerificationRequest, isLiveEvent = false): Promise<void> {\n        // prevent processing the same event multiple times, as under\n        // some circumstances Room.timeline can get emitted twice for the same event\n        if (request.hasEventId(event.getId())) {\n            return;\n        }\n        const type = InRoomChannel.getEventType(event);\n        // do validations that need state (roomId, userId),\n        // ignore if invalid\n\n        if (event.getRoomId() !== this.roomId) {\n            return;\n        }\n        // set userId if not set already\n        if (this.userId === null) {\n            const userId = InRoomChannel.getOtherPartyUserId(event, this.client);\n            if (userId) {\n                this.userId = userId;\n            }\n        }\n        // ignore events not sent by us or the other party\n        const ownUserId = this.client.getUserId();\n        const sender = event.getSender();\n        if (this.userId !== null) {\n            if (sender !== ownUserId && sender !== this.userId) {\n                logger.log(`InRoomChannel: ignoring verification event from ` +\n                    `non-participating sender ${sender}`);\n                return;\n            }\n        }\n        if (this.requestEventId === null) {\n            this.requestEventId = InRoomChannel.getTransactionId(event);\n        }\n\n        const isRemoteEcho = !!event.getUnsigned().transaction_id;\n        const isSentByUs = event.getSender() === this.client.getUserId();\n\n        return request.handleEvent(type, event, isLiveEvent, isRemoteEcho, isSentByUs);\n    }\n\n    /**\n     * Adds the transaction id (relation) back to a received event\n     * so it has the same format as returned by `completeContent` before sending.\n     * The relation can not appear on the event content because of encryption,\n     * relations are excluded from encryption.\n     * @param {MatrixEvent} event the received event\n     * @returns {Object} the content object with the relation added again\n     */\n    public completedContentFromEvent(event: MatrixEvent): Record<string, any> {\n        // ensure m.related_to is included in e2ee rooms\n        // as the field is excluded from encryption\n        const content = Object.assign({}, event.getContent());\n        content[M_RELATES_TO] = event.getRelation();\n        return content;\n    }\n\n    /**\n     * Add all the fields to content needed for sending it over this channel.\n     * This is public so verification methods (SAS uses this) can get the exact\n     * content that will be sent independent of the used channel,\n     * as they need to calculate the hash of it.\n     * @param {string} type the event type\n     * @param {object} content the (incomplete) content\n     * @returns {object} the complete content, as it will be sent.\n     */\n    public completeContent(type: string, content: Record<string, any>): Record<string, any> {\n        content = Object.assign({}, content);\n        if (type === REQUEST_TYPE || type === READY_TYPE || type === START_TYPE) {\n            content.from_device = this.client.getDeviceId();\n        }\n        if (type === REQUEST_TYPE) {\n            // type is mapped to m.room.message in the send method\n            content = {\n                body: this.client.getUserId() + \" is requesting to verify \" +\n                    \"your key, but your client does not support in-chat key \" +\n                    \"verification.  You will need to use legacy key \" +\n                    \"verification to verify keys.\",\n                msgtype: REQUEST_TYPE,\n                to: this.userId,\n                from_device: content.from_device,\n                methods: content.methods,\n            };\n        } else {\n            content[M_RELATES_TO] = {\n                rel_type: M_REFERENCE,\n                event_id: this.transactionId,\n            };\n        }\n        return content;\n    }\n\n    /**\n     * Send an event over the channel with the content not having gone through `completeContent`.\n     * @param {string} type the event type\n     * @param {object} uncompletedContent the (incomplete) content\n     * @returns {Promise} the promise of the request\n     */\n    public send(type: string, uncompletedContent: Record<string, any>): Promise<void> {\n        const content = this.completeContent(type, uncompletedContent);\n        return this.sendCompleted(type, content);\n    }\n\n    /**\n     * Send an event over the channel with the content having gone through `completeContent` already.\n     * @param {string} type the event type\n     * @param {object} content\n     * @returns {Promise} the promise of the request\n     */\n    public async sendCompleted(type: string, content: Record<string, any>): Promise<void> {\n        let sendType = type;\n        if (type === REQUEST_TYPE) {\n            sendType = MESSAGE_TYPE;\n        }\n        const response = await this.client.sendEvent(this.roomId, sendType, content);\n        if (type === REQUEST_TYPE) {\n            this.requestEventId = response.event_id;\n        }\n    }\n}\n\nexport class InRoomRequests implements IRequestsMap {\n    private requestsByRoomId = new Map<string, Map<string, VerificationRequest>>();\n\n    public getRequest(event: MatrixEvent): VerificationRequest {\n        const roomId = event.getRoomId();\n        const txnId = InRoomChannel.getTransactionId(event);\n        return this.getRequestByTxnId(roomId, txnId);\n    }\n\n    public getRequestByChannel(channel: InRoomChannel): VerificationRequest {\n        return this.getRequestByTxnId(channel.roomId, channel.transactionId);\n    }\n\n    private getRequestByTxnId(roomId: string, txnId: string): VerificationRequest {\n        const requestsByTxnId = this.requestsByRoomId.get(roomId);\n        if (requestsByTxnId) {\n            return requestsByTxnId.get(txnId);\n        }\n    }\n\n    public setRequest(event: MatrixEvent, request: VerificationRequest): void {\n        this.doSetRequest(event.getRoomId(), InRoomChannel.getTransactionId(event), request);\n    }\n\n    public setRequestByChannel(channel: IVerificationChannel, request: VerificationRequest): void {\n        this.doSetRequest(channel.roomId, channel.transactionId, request);\n    }\n\n    private doSetRequest(roomId: string, txnId: string, request: VerificationRequest): void {\n        let requestsByTxnId = this.requestsByRoomId.get(roomId);\n        if (!requestsByTxnId) {\n            requestsByTxnId = new Map();\n            this.requestsByRoomId.set(roomId, requestsByTxnId);\n        }\n        requestsByTxnId.set(txnId, request);\n    }\n\n    public removeRequest(event: MatrixEvent): void {\n        const roomId = event.getRoomId();\n        const requestsByTxnId = this.requestsByRoomId.get(roomId);\n        if (requestsByTxnId) {\n            requestsByTxnId.delete(InRoomChannel.getTransactionId(event));\n            if (requestsByTxnId.size === 0) {\n                this.requestsByRoomId.delete(roomId);\n            }\n        }\n    }\n\n    public findRequestInProgress(roomId: string): VerificationRequest {\n        const requestsByTxnId = this.requestsByRoomId.get(roomId);\n        if (requestsByTxnId) {\n            for (const request of requestsByTxnId.values()) {\n                if (request.pending) {\n                    return request;\n                }\n            }\n        }\n    }\n}\n"],"mappings":"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"}