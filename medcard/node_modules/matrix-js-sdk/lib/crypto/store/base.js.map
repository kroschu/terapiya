{"version":3,"file":"base.js","names":[],"sources":["../../../src/crypto/store/base.ts"],"sourcesContent":["/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { IRoomKeyRequestBody, IRoomKeyRequestRecipient } from \"../index\";\nimport { RoomKeyRequestState } from \"../OutgoingRoomKeyRequestManager\";\nimport { ICrossSigningKey } from \"../../client\";\nimport { IOlmDevice } from \"../algorithms/megolm\";\nimport { TrackingStatus } from \"../DeviceList\";\nimport { IRoomEncryption } from \"../RoomList\";\nimport { IDevice } from \"../deviceinfo\";\nimport { ICrossSigningInfo } from \"../CrossSigning\";\nimport { PrefixedLogger } from \"../../logger\";\nimport { InboundGroupSessionData } from \"../OlmDevice\";\nimport { IEncryptedPayload } from \"../aes\";\nimport { MatrixEvent } from \"../../models/event\";\n\n/**\n * Internal module. Definitions for storage for the crypto module\n *\n * @module\n */\n\n/**\n * Abstraction of things that can store data required for end-to-end encryption\n *\n * @interface CryptoStore\n */\nexport interface CryptoStore {\n    startup(): Promise<CryptoStore>;\n    deleteAllData(): Promise<void>;\n    getOrAddOutgoingRoomKeyRequest(request: OutgoingRoomKeyRequest): Promise<OutgoingRoomKeyRequest>;\n    getOutgoingRoomKeyRequest(requestBody: IRoomKeyRequestBody): Promise<OutgoingRoomKeyRequest | null>;\n    getOutgoingRoomKeyRequestByState(wantedStates: number[]): Promise<OutgoingRoomKeyRequest | null>;\n    getAllOutgoingRoomKeyRequestsByState(wantedState: number): Promise<OutgoingRoomKeyRequest[]>;\n    getOutgoingRoomKeyRequestsByTarget(\n        userId: string,\n        deviceId: string,\n        wantedStates: number[],\n    ): Promise<OutgoingRoomKeyRequest[]>;\n    updateOutgoingRoomKeyRequest(\n        requestId: string,\n        expectedState: number,\n        updates: Partial<OutgoingRoomKeyRequest>,\n    ): Promise<OutgoingRoomKeyRequest | null>;\n    deleteOutgoingRoomKeyRequest(requestId: string, expectedState: number): Promise<OutgoingRoomKeyRequest | null>;\n\n    // Olm Account\n    getAccount(txn: unknown, func: (accountPickle: string) => void);\n    storeAccount(txn: unknown, accountPickle: string): void;\n    getCrossSigningKeys(txn: unknown, func: (keys: Record<string, ICrossSigningKey>) => void): void;\n    getSecretStorePrivateKey(txn: unknown, func: (key: IEncryptedPayload | null) => void, type: string): void;\n    storeCrossSigningKeys(txn: unknown, keys: Record<string, ICrossSigningKey>): void;\n    storeSecretStorePrivateKey(txn: unknown, type: string, key: IEncryptedPayload): void;\n\n    // Olm Sessions\n    countEndToEndSessions(txn: unknown, func: (count: number) => void): void;\n    getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: unknown,\n        func: (session: ISessionInfo) => void,\n    ): void;\n    getEndToEndSessions(\n        deviceKey: string,\n        txn: unknown,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void;\n    getAllEndToEndSessions(txn: unknown, func: (session: ISessionInfo) => void): void;\n    storeEndToEndSession(deviceKey: string, sessionId: string, sessionInfo: ISessionInfo, txn: unknown): void;\n    storeEndToEndSessionProblem(deviceKey: string, type: string, fixed: boolean): Promise<void>;\n    getEndToEndSessionProblem(deviceKey: string, timestamp: number): Promise<IProblem | null>;\n    filterOutNotifiedErrorDevices(devices: IOlmDevice[]): Promise<IOlmDevice[]>;\n\n    // Inbound Group Sessions\n    getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: unknown,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void;\n    getAllEndToEndInboundGroupSessions(\n        txn: unknown,\n        func: (session: ISession | null) => void,\n    ): void;\n    addEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void;\n    storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void;\n    storeEndToEndInboundGroupSessionWithheld(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: IWithheld,\n        txn: unknown,\n    ): void;\n\n    // Device Data\n    getEndToEndDeviceData(txn: unknown, func: (deviceData: IDeviceData | null) => void): void;\n    storeEndToEndDeviceData(deviceData: IDeviceData, txn: unknown): void;\n    storeEndToEndRoom(roomId: string, roomInfo: IRoomEncryption, txn: unknown): void;\n    getEndToEndRooms(txn: unknown, func: (rooms: Record<string, IRoomEncryption>) => void): void;\n    getSessionsNeedingBackup(limit: number): Promise<ISession[]>;\n    countSessionsNeedingBackup(txn?: unknown): Promise<number>;\n    unmarkSessionsNeedingBackup(sessions: ISession[], txn?: unknown): Promise<void>;\n    markSessionsNeedingBackup(sessions: ISession[], txn?: unknown): Promise<void>;\n    addSharedHistoryInboundGroupSession(roomId: string, senderKey: string, sessionId: string, txn?: unknown): void;\n    getSharedHistoryInboundGroupSessions(\n        roomId: string,\n        txn?: unknown,\n    ): Promise<[senderKey: string, sessionId: string][]>;\n    addParkedSharedHistory(roomId: string, data: ParkedSharedHistory, txn?: unknown): void;\n    takeParkedSharedHistory(roomId: string, txn?: unknown): Promise<ParkedSharedHistory[]>;\n\n    // Session key backups\n    doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn: unknown) => T, log?: PrefixedLogger): Promise<T>;\n}\n\nexport type Mode = \"readonly\" | \"readwrite\";\n\nexport interface ISession {\n    senderKey: string;\n    sessionId: string;\n    sessionData?: InboundGroupSessionData;\n}\n\nexport interface ISessionInfo {\n    deviceKey?: string;\n    sessionId?: string;\n    session?: string;\n    lastReceivedMessageTs?: number;\n}\n\nexport interface IDeviceData {\n    devices: {\n        [ userId: string ]: {\n            [ deviceId: string ]: IDevice;\n        };\n    };\n    trackingStatus: {\n        [ userId: string ]: TrackingStatus;\n    };\n    crossSigningInfo?: Record<string, ICrossSigningInfo>;\n    syncToken?: string;\n}\n\nexport interface IProblem {\n    type: string;\n    fixed: boolean;\n    time: number;\n}\n\nexport interface IWithheld {\n    // eslint-disable-next-line camelcase\n    room_id: string;\n    code: string;\n    reason: string;\n}\n\n/**\n * Represents an outgoing room key request\n *\n * @typedef {Object} OutgoingRoomKeyRequest\n *\n * @property {string} requestId    unique id for this request. Used for both\n *    an id within the request for later pairing with a cancellation, and for\n *    the transaction id when sending the to_device messages to our local\n *    server.\n *\n * @property {string?} cancellationTxnId\n *    transaction id for the cancellation, if any\n *\n * @property {Array<{userId: string, deviceId: string}>} recipients\n *    list of recipients for the request\n *\n * @property {module:crypto~RoomKeyRequestBody} requestBody\n *    parameters for the request.\n *\n * @property {Number} state   current state of this request (states are defined\n *    in {@link module:crypto/OutgoingRoomKeyRequestManager~ROOM_KEY_REQUEST_STATES})\n */\nexport interface OutgoingRoomKeyRequest {\n    requestId: string;\n    requestTxnId?: string;\n    cancellationTxnId?: string;\n    recipients: IRoomKeyRequestRecipient[];\n    requestBody: IRoomKeyRequestBody;\n    state: RoomKeyRequestState;\n}\n\nexport interface ParkedSharedHistory {\n    senderId: string;\n    senderKey: string;\n    sessionId: string;\n    sessionKey: string;\n    keysClaimed: ReturnType<MatrixEvent[\"getKeysClaimed\"]>; // XXX: Less type dependence on MatrixEvent\n    forwardingCurve25519KeyChain: string[];\n}\n"],"mappings":""}