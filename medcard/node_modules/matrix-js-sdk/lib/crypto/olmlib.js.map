{"version":3,"file":"olmlib.js","names":["Algorithm","OLM_ALGORITHM","Olm","MEGOLM_ALGORITHM","Megolm","MEGOLM_BACKUP_ALGORITHM","MegolmBackup","encryptMessageForDevice","resultsObject","ourUserId","ourDeviceId","olmDevice","recipientUserId","recipientDevice","payloadFields","deviceKey","getIdentityKey","sessionId","getSessionIdForDevice","logger","log","deviceId","payload","sender","sender_device","keys","deviceEd25519Key","recipient","recipient_keys","getFingerprint","Object","assign","encryptMessage","JSON","stringify","getExistingOlmSessions","baseApis","devicesByUser","devicesWithoutSession","sessions","promises","userId","devices","entries","deviceInfo","key","push","device","Promise","all","ensureOlmSessionsForDevices","force","otkTimeout","failedServers","result","resolveSession","deviceCurve25519Key","sessionsInProgress","resolve","v","info","forWhom","length","oneTimeKeyAlgorithm","res","taskDetail","debug","claimOneTimeKeys","e","resolver","values","failures","otkResult","one_time_keys","userRes","j","deviceRes","oneTimeKey","keyId","indexOf","warn","_verifyKeyAndStartSession","then","sid","verifySignature","error","createOutboundSession","obj","signingUserId","signingDeviceId","signingKey","signKeyId","signatures","userSigs","signature","Error","mangledObj","unsigned","json","anotherjson","pkSign","pubKey","createdKey","Uint8Array","keyObj","global","PkSigning","init_with_seed","sigs","mysigs","sign","free","pkVerify","util","Utility","ed25519_verify","isOlmEncrypted","event","getSenderKey","getWireType","EventType","RoomMessageEncrypted","includes","getWireContent","algorithm","encodeBase64","uint8Array","Buffer","from","toString","encodeUnpaddedBase64","replace","decodeBase64","base64"],"sources":["../../src/crypto/olmlib.ts"],"sourcesContent":["/*\nCopyright 2016 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @module olmlib\n *\n * Utilities common to olm encryption algorithms\n */\n\nimport anotherjson from \"another-json\";\nimport { Logger } from \"loglevel\";\n\nimport type { PkSigning } from \"@matrix-org/olm\";\nimport { OlmDevice } from \"./OlmDevice\";\nimport { DeviceInfo } from \"./deviceinfo\";\nimport { logger } from '../logger';\nimport { IOneTimeKey } from \"./dehydration\";\nimport { IClaimOTKsResult, MatrixClient } from \"../client\";\nimport { ISignatures } from \"../@types/signed\";\nimport { MatrixEvent } from \"../models/event\";\nimport { EventType } from \"../@types/event\";\n\nenum Algorithm {\n    Olm = \"m.olm.v1.curve25519-aes-sha2\",\n    Megolm = \"m.megolm.v1.aes-sha2\",\n    MegolmBackup = \"m.megolm_backup.v1.curve25519-aes-sha2\",\n}\n\n/**\n * matrix algorithm tag for olm\n */\nexport const OLM_ALGORITHM = Algorithm.Olm;\n\n/**\n * matrix algorithm tag for megolm\n */\nexport const MEGOLM_ALGORITHM = Algorithm.Megolm;\n\n/**\n * matrix algorithm tag for megolm backups\n */\nexport const MEGOLM_BACKUP_ALGORITHM = Algorithm.MegolmBackup;\n\nexport interface IOlmSessionResult {\n    device: DeviceInfo;\n    sessionId?: string;\n}\n\n/**\n * Encrypt an event payload for an Olm device\n *\n * @param {Object<string, string>} resultsObject  The `ciphertext` property\n *   of the m.room.encrypted event to which to add our result\n *\n * @param {string} ourUserId\n * @param {string} ourDeviceId\n * @param {module:crypto/OlmDevice} olmDevice olm.js wrapper\n * @param {string} recipientUserId\n * @param {module:crypto/deviceinfo} recipientDevice\n * @param {object} payloadFields fields to include in the encrypted payload\n *\n * Returns a promise which resolves (to undefined) when the payload\n *    has been encrypted into `resultsObject`\n */\nexport async function encryptMessageForDevice(\n    resultsObject: Record<string, string>,\n    ourUserId: string,\n    ourDeviceId: string | undefined,\n    olmDevice: OlmDevice,\n    recipientUserId: string,\n    recipientDevice: DeviceInfo,\n    payloadFields: Record<string, any>,\n) {\n    const deviceKey = recipientDevice.getIdentityKey();\n    const sessionId = await olmDevice.getSessionIdForDevice(deviceKey);\n    if (sessionId === null) {\n        // If we don't have a session for a device then\n        // we can't encrypt a message for it.\n        return;\n    }\n\n    logger.log(\n        \"Using sessionid \" + sessionId + \" for device \" +\n            recipientUserId + \":\" + recipientDevice.deviceId,\n    );\n\n    const payload = {\n        sender: ourUserId,\n        // TODO this appears to no longer be used whatsoever\n        sender_device: ourDeviceId,\n\n        // Include the Ed25519 key so that the recipient knows what\n        // device this message came from.\n        // We don't need to include the curve25519 key since the\n        // recipient will already know this from the olm headers.\n        // When combined with the device keys retrieved from the\n        // homeserver signed by the ed25519 key this proves that\n        // the curve25519 key and the ed25519 key are owned by\n        // the same device.\n        keys: {\n            \"ed25519\": olmDevice.deviceEd25519Key,\n        },\n\n        // include the recipient device details in the payload,\n        // to avoid unknown key attacks, per\n        // https://github.com/vector-im/vector-web/issues/2483\n        recipient: recipientUserId,\n        recipient_keys: {\n            \"ed25519\": recipientDevice.getFingerprint(),\n        },\n    };\n\n    // TODO: technically, a bunch of that stuff only needs to be included for\n    // pre-key messages: after that, both sides know exactly which devices are\n    // involved in the session. If we're looking to reduce data transfer in the\n    // future, we could elide them for subsequent messages.\n\n    Object.assign(payload, payloadFields);\n\n    resultsObject[deviceKey] = await olmDevice.encryptMessage(\n        deviceKey, sessionId, JSON.stringify(payload),\n    );\n}\n\ninterface IExistingOlmSession {\n    device: DeviceInfo;\n    sessionId?: string;\n}\n\n/**\n * Get the existing olm sessions for the given devices, and the devices that\n * don't have olm sessions.\n *\n * @param {module:crypto/OlmDevice} olmDevice\n *\n * @param {MatrixClient} baseApis\n *\n * @param {object<string, module:crypto/deviceinfo[]>} devicesByUser\n *    map from userid to list of devices to ensure sessions for\n *\n * @return {Promise} resolves to an array.  The first element of the array is a\n *    a map of user IDs to arrays of deviceInfo, representing the devices that\n *    don't have established olm sessions.  The second element of the array is\n *    a map from userId to deviceId to {@link module:crypto~OlmSessionResult}\n */\nexport async function getExistingOlmSessions(\n    olmDevice: OlmDevice,\n    baseApis: MatrixClient,\n    devicesByUser: Record<string, DeviceInfo[]>,\n): Promise<[Record<string, DeviceInfo[]>, Record<string, Record<string, IExistingOlmSession>>]> {\n    const devicesWithoutSession: {[userId: string]: DeviceInfo[]} = {};\n    const sessions: {[userId: string]: {[deviceId: string]: IExistingOlmSession}} = {};\n\n    const promises: Promise<void>[] = [];\n\n    for (const [userId, devices] of Object.entries(devicesByUser)) {\n        for (const deviceInfo of devices) {\n            const deviceId = deviceInfo.deviceId;\n            const key = deviceInfo.getIdentityKey();\n            promises.push((async () => {\n                const sessionId = await olmDevice.getSessionIdForDevice(\n                    key, true,\n                );\n                if (sessionId === null) {\n                    devicesWithoutSession[userId] = devicesWithoutSession[userId] || [];\n                    devicesWithoutSession[userId].push(deviceInfo);\n                } else {\n                    sessions[userId] = sessions[userId] || {};\n                    sessions[userId][deviceId] = {\n                        device: deviceInfo,\n                        sessionId: sessionId,\n                    };\n                }\n            })());\n        }\n    }\n\n    await Promise.all(promises);\n\n    return [devicesWithoutSession, sessions];\n}\n\n/**\n * Try to make sure we have established olm sessions for the given devices.\n *\n * @param {module:crypto/OlmDevice} olmDevice\n *\n * @param {MatrixClient} baseApis\n *\n * @param {object<string, module:crypto/deviceinfo[]>} devicesByUser\n *    map from userid to list of devices to ensure sessions for\n *\n * @param {boolean} [force=false] If true, establish a new session even if one\n *     already exists.\n *\n * @param {Number} [otkTimeout] The timeout in milliseconds when requesting\n *     one-time keys for establishing new olm sessions.\n *\n * @param {Array} [failedServers] An array to fill with remote servers that\n *     failed to respond to one-time-key requests.\n *\n * @param {Logger} [log] A possibly customised log\n *\n * @return {Promise} resolves once the sessions are complete, to\n *    an Object mapping from userId to deviceId to\n *    {@link module:crypto~OlmSessionResult}\n */\nexport async function ensureOlmSessionsForDevices(\n    olmDevice: OlmDevice,\n    baseApis: MatrixClient,\n    devicesByUser: Record<string, DeviceInfo[]>,\n    force = false,\n    otkTimeout?: number,\n    failedServers?: string[],\n    log: Logger = logger,\n): Promise<Record<string, Record<string, IOlmSessionResult>>> {\n    if (typeof force === \"number\") {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - backwards compatibility\n        log = failedServers;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - backwards compatibility\n        failedServers = otkTimeout;\n        otkTimeout = force;\n        force = false;\n    }\n\n    const devicesWithoutSession: [string, string][] = [\n        // [userId, deviceId], ...\n    ];\n    const result: {[userId: string]: {[deviceId: string]: IExistingOlmSession}} = {};\n    const resolveSession: Record<string, (sessionId?: string) => void> = {};\n\n    // Mark all sessions this task intends to update as in progress. It is\n    // important to do this for all devices this task cares about in a single\n    // synchronous operation, as otherwise it is possible to have deadlocks\n    // where multiple tasks wait indefinitely on another task to update some set\n    // of common devices.\n    for (const [, devices] of Object.entries(devicesByUser)) {\n        for (const deviceInfo of devices) {\n            const key = deviceInfo.getIdentityKey();\n\n            if (key === olmDevice.deviceCurve25519Key) {\n                // We don't start sessions with ourself, so there's no need to\n                // mark it in progress.\n                continue;\n            }\n\n            if (!olmDevice.sessionsInProgress[key]) {\n                // pre-emptively mark the session as in-progress to avoid race\n                // conditions.  If we find that we already have a session, then\n                // we'll resolve\n                olmDevice.sessionsInProgress[key] = new Promise(resolve => {\n                    resolveSession[key] = (v: any) => {\n                        delete olmDevice.sessionsInProgress[key];\n                        resolve(v);\n                    };\n                });\n            }\n        }\n    }\n\n    for (const [userId, devices] of Object.entries(devicesByUser)) {\n        result[userId] = {};\n        for (const deviceInfo of devices) {\n            const deviceId = deviceInfo.deviceId;\n            const key = deviceInfo.getIdentityKey();\n\n            if (key === olmDevice.deviceCurve25519Key) {\n                // We should never be trying to start a session with ourself.\n                // Apart from talking to yourself being the first sign of madness,\n                // olm sessions can't do this because they get confused when\n                // they get a message and see that the 'other side' has started a\n                // new chain when this side has an active sender chain.\n                // If you see this message being logged in the wild, we should find\n                // the thing that is trying to send Olm messages to itself and fix it.\n                log.info(\"Attempted to start session with ourself! Ignoring\");\n                // We must fill in the section in the return value though, as callers\n                // expect it to be there.\n                result[userId][deviceId] = {\n                    device: deviceInfo,\n                    sessionId: null,\n                };\n                continue;\n            }\n\n            const forWhom = `for ${key} (${userId}:${deviceId})`;\n            const sessionId = await olmDevice.getSessionIdForDevice(key, !!resolveSession[key], log);\n            if (sessionId !== null && resolveSession[key]) {\n                // we found a session, but we had marked the session as\n                // in-progress, so resolve it now, which will unmark it and\n                // unblock anything that was waiting\n                resolveSession[key]();\n            }\n            if (sessionId === null || force) {\n                if (force) {\n                    log.info(`Forcing new Olm session ${forWhom}`);\n                } else {\n                    log.info(`Making new Olm session ${forWhom}`);\n                }\n                devicesWithoutSession.push([userId, deviceId]);\n            }\n            result[userId][deviceId] = {\n                device: deviceInfo,\n                sessionId: sessionId,\n            };\n        }\n    }\n\n    if (devicesWithoutSession.length === 0) {\n        return result;\n    }\n\n    const oneTimeKeyAlgorithm = \"signed_curve25519\";\n    let res: IClaimOTKsResult;\n    let taskDetail = `one-time keys for ${devicesWithoutSession.length} devices`;\n    try {\n        log.debug(`Claiming ${taskDetail}`);\n        res = await baseApis.claimOneTimeKeys(devicesWithoutSession, oneTimeKeyAlgorithm, otkTimeout);\n        log.debug(`Claimed ${taskDetail}`);\n    } catch (e) {\n        for (const resolver of Object.values(resolveSession)) {\n            resolver();\n        }\n        log.log(`Failed to claim ${taskDetail}`, e, devicesWithoutSession);\n        throw e;\n    }\n\n    if (failedServers && \"failures\" in res) {\n        failedServers.push(...Object.keys(res.failures));\n    }\n\n    const otkResult = res.one_time_keys || {} as IClaimOTKsResult[\"one_time_keys\"];\n    const promises: Promise<void>[] = [];\n    for (const [userId, devices] of Object.entries(devicesByUser)) {\n        const userRes = otkResult[userId] || {};\n        for (let j = 0; j < devices.length; j++) {\n            const deviceInfo = devices[j];\n            const deviceId = deviceInfo.deviceId;\n            const key = deviceInfo.getIdentityKey();\n\n            if (key === olmDevice.deviceCurve25519Key) {\n                // We've already logged about this above. Skip here too\n                // otherwise we'll log saying there are no one-time keys\n                // which will be confusing.\n                continue;\n            }\n\n            if (result[userId][deviceId].sessionId && !force) {\n                // we already have a result for this device\n                continue;\n            }\n\n            const deviceRes = userRes[deviceId] || {};\n            let oneTimeKey: IOneTimeKey = null;\n            for (const keyId in deviceRes) {\n                if (keyId.indexOf(oneTimeKeyAlgorithm + \":\") === 0) {\n                    oneTimeKey = deviceRes[keyId];\n                }\n            }\n\n            if (!oneTimeKey) {\n                log.warn(\n                    `No one-time keys (alg=${oneTimeKeyAlgorithm}) ` +\n                    `for device ${userId}:${deviceId}`,\n                );\n                if (resolveSession[key]) {\n                    resolveSession[key]();\n                }\n                continue;\n            }\n\n            promises.push(\n                _verifyKeyAndStartSession(\n                    olmDevice, oneTimeKey, userId, deviceInfo,\n                ).then((sid) => {\n                    if (resolveSession[key]) {\n                        resolveSession[key](sid);\n                    }\n                    result[userId][deviceId].sessionId = sid;\n                }, (e) => {\n                    if (resolveSession[key]) {\n                        resolveSession[key]();\n                    }\n                    throw e;\n                }),\n            );\n        }\n    }\n\n    taskDetail = `Olm sessions for ${promises.length} devices`;\n    log.debug(`Starting ${taskDetail}`);\n    await Promise.all(promises);\n    log.debug(`Started ${taskDetail}`);\n    return result;\n}\n\nasync function _verifyKeyAndStartSession(\n    olmDevice: OlmDevice,\n    oneTimeKey: IOneTimeKey,\n    userId: string,\n    deviceInfo: DeviceInfo,\n): Promise<string> {\n    const deviceId = deviceInfo.deviceId;\n    try {\n        await verifySignature(\n            olmDevice, oneTimeKey, userId, deviceId,\n            deviceInfo.getFingerprint(),\n        );\n    } catch (e) {\n        logger.error(\n            \"Unable to verify signature on one-time key for device \" +\n                userId + \":\" + deviceId + \":\", e,\n        );\n        return null;\n    }\n\n    let sid;\n    try {\n        sid = await olmDevice.createOutboundSession(\n            deviceInfo.getIdentityKey(), oneTimeKey.key,\n        );\n    } catch (e) {\n        // possibly a bad key\n        logger.error(\"Error starting olm session with device \" +\n                      userId + \":\" + deviceId + \": \" + e);\n        return null;\n    }\n\n    logger.log(\"Started new olm sessionid \" + sid +\n                \" for device \" + userId + \":\" + deviceId);\n    return sid;\n}\n\nexport interface IObject {\n    unsigned?: object;\n    signatures?: ISignatures;\n}\n\n/**\n * Verify the signature on an object\n *\n * @param {module:crypto/OlmDevice} olmDevice olm wrapper to use for verify op\n *\n * @param {Object} obj object to check signature on.\n *\n * @param {string} signingUserId  ID of the user whose signature should be checked\n *\n * @param {string} signingDeviceId  ID of the device whose signature should be checked\n *\n * @param {string} signingKey   base64-ed ed25519 public key\n *\n * Returns a promise which resolves (to undefined) if the the signature is good,\n * or rejects with an Error if it is bad.\n */\nexport async function verifySignature(\n    olmDevice: OlmDevice,\n    obj: IOneTimeKey | IObject,\n    signingUserId: string,\n    signingDeviceId: string,\n    signingKey: string,\n) {\n    const signKeyId = \"ed25519:\" + signingDeviceId;\n    const signatures = obj.signatures || {};\n    const userSigs = signatures[signingUserId] || {};\n    const signature = userSigs[signKeyId];\n    if (!signature) {\n        throw Error(\"No signature\");\n    }\n\n    // prepare the canonical json: remove unsigned and signatures, and stringify with anotherjson\n    const mangledObj = Object.assign({}, obj);\n    if (\"unsigned\" in mangledObj) {\n        delete mangledObj.unsigned;\n    }\n    delete mangledObj.signatures;\n    const json = anotherjson.stringify(mangledObj);\n\n    olmDevice.verifySignature(\n        signingKey, json, signature,\n    );\n}\n\n/**\n * Sign a JSON object using public key cryptography\n * @param {Object} obj Object to sign.  The object will be modified to include\n *     the new signature\n * @param {Olm.PkSigning|Uint8Array} key the signing object or the private key\n * seed\n * @param {string} userId The user ID who owns the signing key\n * @param {string} pubKey The public key (ignored if key is a seed)\n * @returns {string} the signature for the object\n */\nexport function pkSign(obj: IObject, key: PkSigning, userId: string, pubKey: string): string {\n    let createdKey = false;\n    if (key instanceof Uint8Array) {\n        const keyObj = new global.Olm.PkSigning();\n        pubKey = keyObj.init_with_seed(key);\n        key = keyObj;\n        createdKey = true;\n    }\n    const sigs = obj.signatures || {};\n    delete obj.signatures;\n    const unsigned = obj.unsigned;\n    if (obj.unsigned) delete obj.unsigned;\n    try {\n        const mysigs = sigs[userId] || {};\n        sigs[userId] = mysigs;\n\n        return mysigs['ed25519:' + pubKey] = key.sign(anotherjson.stringify(obj));\n    } finally {\n        obj.signatures = sigs;\n        if (unsigned) obj.unsigned = unsigned;\n        if (createdKey) {\n            key.free();\n        }\n    }\n}\n\n/**\n * Verify a signed JSON object\n * @param {Object} obj Object to verify\n * @param {string} pubKey The public key to use to verify\n * @param {string} userId The user ID who signed the object\n */\nexport function pkVerify(obj: IObject, pubKey: string, userId: string) {\n    const keyId = \"ed25519:\" + pubKey;\n    if (!(obj.signatures && obj.signatures[userId] && obj.signatures[userId][keyId])) {\n        throw new Error(\"No signature\");\n    }\n    const signature = obj.signatures[userId][keyId];\n    const util = new global.Olm.Utility();\n    const sigs = obj.signatures;\n    delete obj.signatures;\n    const unsigned = obj.unsigned;\n    if (obj.unsigned) delete obj.unsigned;\n    try {\n        util.ed25519_verify(pubKey, anotherjson.stringify(obj), signature);\n    } finally {\n        obj.signatures = sigs;\n        if (unsigned) obj.unsigned = unsigned;\n        util.free();\n    }\n}\n\n/**\n * Check that an event was encrypted using olm.\n */\nexport function isOlmEncrypted(event: MatrixEvent): boolean {\n    if (!event.getSenderKey()) {\n        logger.error(\"Event has no sender key (not encrypted?)\");\n        return false;\n    }\n    if (event.getWireType() !== EventType.RoomMessageEncrypted ||\n        !([\"m.olm.v1.curve25519-aes-sha2\"].includes(event.getWireContent().algorithm))) {\n        logger.error(\"Event was not encrypted using an appropriate algorithm\");\n        return false;\n    }\n    return true;\n}\n\n/**\n * Encode a typed array of uint8 as base64.\n * @param {Uint8Array} uint8Array The data to encode.\n * @return {string} The base64.\n */\nexport function encodeBase64(uint8Array: ArrayBuffer | Uint8Array): string {\n    return Buffer.from(uint8Array).toString(\"base64\");\n}\n\n/**\n * Encode a typed array of uint8 as unpadded base64.\n * @param {Uint8Array} uint8Array The data to encode.\n * @return {string} The unpadded base64.\n */\nexport function encodeUnpaddedBase64(uint8Array: ArrayBuffer | Uint8Array): string {\n    return encodeBase64(uint8Array).replace(/=+$/g, '');\n}\n\n/**\n * Decode a base64 string to a typed array of uint8.\n * @param {string} base64 The base64 to decode.\n * @return {Uint8Array} The decoded data.\n */\nexport function decodeBase64(base64: string): Uint8Array {\n    return Buffer.from(base64, \"base64\");\n}\n"],"mappings":"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"}