{"version":3,"file":"indexeddb-local-backend.js","names":["DB_MIGRATIONS","db","createObjectStore","keyPath","oobMembersStore","createIndex","autoIncrement","VERSION","length","selectQuery","store","keyRange","resultMapper","query","openCursor","Promise","resolve","reject","results","onerror","Error","error","onsuccess","cursor","result","push","continue","txnAsPromise","txn","oncomplete","event","reqAsEventPromise","req","reqAsPromise","err","reqAsCursorPromise","then","LocalIndexedDBStoreBackend","exists","indexedDB","dbName","IndexedDBHelpers","constructor","syncAccumulator","SyncAccumulator","connect","disconnected","logger","log","open","onupgradeneeded","ev","oldVersion","_isNewlyCreated","forEach","migration","index","onblocked","onversionchange","close","init","isNewlyCreated","all","loadAccountData","loadSyncData","accountData","syncData","accumulate","next_batch","nextBatch","rooms","roomsData","account_data","events","getOutOfBandMembers","roomId","tx","transaction","objectStore","roomIndex","range","IDBKeyRange","only","request","membershipEvents","oobWritten","record","value","oob_written","setOutOfBandMembers","e","put","markerObject","room_id","state_key","clearOutOfBandMembers","readTx","roomRange","minStateKeyProm","openKeyCursor","primaryKey","maxStateKeyProm","minStateKey","maxStateKey","writeTx","writeStore","membersKeyRange","bound","delete","clearDatabase","deleteDatabase","warn","getSavedSync","copy","data","getJSON","utils","deepCopy","getNextBatchToken","setSyncData","syncToDatabase","userTuples","isPersisting","pendingUserPresenceData","unshift","persistUserPresenceEvents","persistAccountData","persistSyncData","promiseTry","clobber","i","tuples","tuple","userId","getUserPresenceEvents","undefined","getClientOptions","options","storeClientOptions","saveToDeviceBatches","batches","batch","add","getOldestToDeviceBatch","resultBatch","id","key","txnId","eventType","removeToDeviceBatch"],"sources":["../../src/store/indexeddb-local-backend.ts"],"sourcesContent":["/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { IMinimalEvent, ISyncData, ISyncResponse, SyncAccumulator } from \"../sync-accumulator\";\nimport * as utils from \"../utils\";\nimport * as IndexedDBHelpers from \"../indexeddb-helpers\";\nimport { logger } from '../logger';\nimport { IStartClientOpts, IStateEventWithRoomId } from \"../matrix\";\nimport { ISavedSync } from \"./index\";\nimport { IIndexedDBBackend, UserTuple } from \"./indexeddb-backend\";\nimport { IndexedToDeviceBatch, ToDeviceBatchWithTxnId } from \"../models/ToDeviceMessage\";\n\ntype DbMigration = (db: IDBDatabase) => void;\nconst DB_MIGRATIONS: DbMigration[] = [\n    (db) => {\n        // Make user store, clobber based on user ID. (userId property of User objects)\n        db.createObjectStore(\"users\", { keyPath: [\"userId\"] });\n\n        // Make account data store, clobber based on event type.\n        // (event.type property of MatrixEvent objects)\n        db.createObjectStore(\"accountData\", { keyPath: [\"type\"] });\n\n        // Make /sync store (sync tokens, room data, etc), always clobber (const key).\n        db.createObjectStore(\"sync\", { keyPath: [\"clobber\"] });\n    },\n    (db) => {\n        const oobMembersStore = db.createObjectStore(\n            \"oob_membership_events\", {\n                keyPath: [\"room_id\", \"state_key\"],\n            });\n        oobMembersStore.createIndex(\"room\", \"room_id\");\n    },\n    (db) => { db.createObjectStore(\"client_options\", { keyPath: [\"clobber\"] }); },\n    (db) => { db.createObjectStore(\"to_device_queue\", { autoIncrement: true }); },\n    // Expand as needed.\n];\nconst VERSION = DB_MIGRATIONS.length;\n\n/**\n * Helper method to collect results from a Cursor and promiseify it.\n * @param {ObjectStore|Index} store The store to perform openCursor on.\n * @param {IDBKeyRange=} keyRange Optional key range to apply on the cursor.\n * @param {Function} resultMapper A function which is repeatedly called with a\n * Cursor.\n * Return the data you want to keep.\n * @return {Promise<T[]>} Resolves to an array of whatever you returned from\n * resultMapper.\n */\nfunction selectQuery<T>(\n    store: IDBObjectStore,\n    keyRange: IDBKeyRange | IDBValidKey | undefined,\n    resultMapper: (cursor: IDBCursorWithValue) => T,\n): Promise<T[]> {\n    const query = store.openCursor(keyRange);\n    return new Promise((resolve, reject) => {\n        const results: T[] = [];\n        query.onerror = () => {\n            reject(new Error(\"Query failed: \" + query.error));\n        };\n        // collect results\n        query.onsuccess = () => {\n            const cursor = query.result;\n            if (!cursor) {\n                resolve(results);\n                return; // end of results\n            }\n            results.push(resultMapper(cursor));\n            cursor.continue();\n        };\n    });\n}\n\nfunction txnAsPromise(txn: IDBTransaction): Promise<Event> {\n    return new Promise((resolve, reject) => {\n        txn.oncomplete = function(event) {\n            resolve(event);\n        };\n        txn.onerror = function() {\n            reject(txn.error);\n        };\n    });\n}\n\nfunction reqAsEventPromise(req: IDBRequest): Promise<Event> {\n    return new Promise((resolve, reject) => {\n        req.onsuccess = function(event) {\n            resolve(event);\n        };\n        req.onerror = function() {\n            reject(req.error);\n        };\n    });\n}\n\nfunction reqAsPromise(req: IDBRequest): Promise<IDBRequest> {\n    return new Promise((resolve, reject) => {\n        req.onsuccess = () => resolve(req);\n        req.onerror = (err) => reject(err);\n    });\n}\n\nfunction reqAsCursorPromise<T>(req: IDBRequest<T>): Promise<T> {\n    return reqAsEventPromise(req).then((event) => req.result);\n}\n\nexport class LocalIndexedDBStoreBackend implements IIndexedDBBackend {\n    public static exists(indexedDB: IDBFactory, dbName: string): Promise<boolean> {\n        dbName = \"matrix-js-sdk:\" + (dbName || \"default\");\n        return IndexedDBHelpers.exists(indexedDB, dbName);\n    }\n\n    private readonly dbName: string;\n    private readonly syncAccumulator: SyncAccumulator;\n    private db: IDBDatabase = null;\n    private disconnected = true;\n    private _isNewlyCreated = false;\n    private isPersisting = false;\n    private pendingUserPresenceData: UserTuple[] = [];\n\n    /**\n     * Does the actual reading from and writing to the indexeddb\n     *\n     * Construct a new Indexed Database store backend. This requires a call to\n     * <code>connect()</code> before this store can be used.\n     * @constructor\n     * @param {Object} indexedDB The Indexed DB interface e.g\n     * <code>window.indexedDB</code>\n     * @param {string=} dbName Optional database name. The same name must be used\n     * to open the same database.\n     */\n    constructor(private readonly indexedDB: IDBFactory, dbName: string) {\n        this.dbName = \"matrix-js-sdk:\" + (dbName || \"default\");\n        this.syncAccumulator = new SyncAccumulator();\n    }\n\n    /**\n     * Attempt to connect to the database. This can fail if the user does not\n     * grant permission.\n     * @return {Promise} Resolves if successfully connected.\n     */\n    public connect(): Promise<void> {\n        if (!this.disconnected) {\n            logger.log(`LocalIndexedDBStoreBackend.connect: already connected or connecting`);\n            return Promise.resolve();\n        }\n\n        this.disconnected = false;\n\n        logger.log(`LocalIndexedDBStoreBackend.connect: connecting...`);\n        const req = this.indexedDB.open(this.dbName, VERSION);\n        req.onupgradeneeded = (ev) => {\n            const db = req.result;\n            const oldVersion = ev.oldVersion;\n            logger.log(\n                `LocalIndexedDBStoreBackend.connect: upgrading from ${oldVersion}`,\n            );\n            if (oldVersion < 1) {\n                // The database did not previously exist\n                this._isNewlyCreated = true;\n            }\n            DB_MIGRATIONS.forEach((migration, index) => {\n                if (oldVersion <= index) migration(db);\n            });\n        };\n\n        req.onblocked = () => {\n            logger.log(`can't yet open LocalIndexedDBStoreBackend because it is open elsewhere`);\n        };\n\n        logger.log(`LocalIndexedDBStoreBackend.connect: awaiting connection...`);\n        return reqAsEventPromise(req).then(() => {\n            logger.log(`LocalIndexedDBStoreBackend.connect: connected`);\n            this.db = req.result;\n\n            // add a poorly-named listener for when deleteDatabase is called\n            // so we can close our db connections.\n            this.db.onversionchange = () => {\n                this.db.close();\n            };\n\n            return this.init();\n        });\n    }\n\n    /** @return {boolean} whether or not the database was newly created in this session. */\n    public isNewlyCreated(): Promise<boolean> {\n        return Promise.resolve(this._isNewlyCreated);\n    }\n\n    /**\n     * Having connected, load initial data from the database and prepare for use\n     * @return {Promise} Resolves on success\n     */\n    private init() {\n        return Promise.all([\n            this.loadAccountData(),\n            this.loadSyncData(),\n        ]).then(([accountData, syncData]) => {\n            logger.log(`LocalIndexedDBStoreBackend: loaded initial data`);\n            this.syncAccumulator.accumulate({\n                next_batch: syncData.nextBatch,\n                rooms: syncData.roomsData,\n                account_data: {\n                    events: accountData,\n                },\n            }, true);\n        });\n    }\n\n    /**\n     * Returns the out-of-band membership events for this room that\n     * were previously loaded.\n     * @param {string} roomId\n     * @returns {Promise<event[]>} the events, potentially an empty array if OOB loading didn't yield any new members\n     * @returns {null} in case the members for this room haven't been stored yet\n     */\n    public getOutOfBandMembers(roomId: string): Promise<IStateEventWithRoomId[] | null> {\n        return new Promise<IStateEventWithRoomId[] | null>((resolve, reject) => {\n            const tx = this.db.transaction([\"oob_membership_events\"], \"readonly\");\n            const store = tx.objectStore(\"oob_membership_events\");\n            const roomIndex = store.index(\"room\");\n            const range = IDBKeyRange.only(roomId);\n            const request = roomIndex.openCursor(range);\n\n            const membershipEvents: IStateEventWithRoomId[] = [];\n            // did we encounter the oob_written marker object\n            // amongst the results? That means OOB member\n            // loading already happened for this room\n            // but there were no members to persist as they\n            // were all known already\n            let oobWritten = false;\n\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (!cursor) {\n                    // Unknown room\n                    if (!membershipEvents.length && !oobWritten) {\n                        return resolve(null);\n                    }\n                    return resolve(membershipEvents);\n                }\n                const record = cursor.value;\n                if (record.oob_written) {\n                    oobWritten = true;\n                } else {\n                    membershipEvents.push(record);\n                }\n                cursor.continue();\n            };\n            request.onerror = (err) => {\n                reject(err);\n            };\n        }).then((events) => {\n            logger.log(`LL: got ${events?.length} membershipEvents from storage for room ${roomId} ...`);\n            return events;\n        });\n    }\n\n    /**\n     * Stores the out-of-band membership events for this room. Note that\n     * it still makes sense to store an empty array as the OOB status for the room is\n     * marked as fetched, and getOutOfBandMembers will return an empty array instead of null\n     * @param {string} roomId\n     * @param {event[]} membershipEvents the membership events to store\n     */\n    public async setOutOfBandMembers(roomId: string, membershipEvents: IStateEventWithRoomId[]): Promise<void> {\n        logger.log(`LL: backend about to store ${membershipEvents.length}` +\n            ` members for ${roomId}`);\n        const tx = this.db.transaction([\"oob_membership_events\"], \"readwrite\");\n        const store = tx.objectStore(\"oob_membership_events\");\n        membershipEvents.forEach((e) => {\n            store.put(e);\n        });\n        // aside from all the events, we also write a marker object to the store\n        // to mark the fact that OOB members have been written for this room.\n        // It's possible that 0 members need to be written as all where previously know\n        // but we still need to know whether to return null or [] from getOutOfBandMembers\n        // where null means out of band members haven't been stored yet for this room\n        const markerObject = {\n            room_id: roomId,\n            oob_written: true,\n            state_key: 0,\n        };\n        store.put(markerObject);\n        await txnAsPromise(tx);\n        logger.log(`LL: backend done storing for ${roomId}!`);\n    }\n\n    public async clearOutOfBandMembers(roomId: string): Promise<void> {\n        // the approach to delete all members for a room\n        // is to get the min and max state key from the index\n        // for that room, and then delete between those\n        // keys in the store.\n        // this should be way faster than deleting every member\n        // individually for a large room.\n        const readTx = this.db.transaction(\n            [\"oob_membership_events\"],\n            \"readonly\");\n        const store = readTx.objectStore(\"oob_membership_events\");\n        const roomIndex = store.index(\"room\");\n        const roomRange = IDBKeyRange.only(roomId);\n\n        const minStateKeyProm = reqAsCursorPromise(\n            roomIndex.openKeyCursor(roomRange, \"next\"),\n        ).then((cursor) => cursor && cursor.primaryKey[1]);\n        const maxStateKeyProm = reqAsCursorPromise(\n            roomIndex.openKeyCursor(roomRange, \"prev\"),\n        ).then((cursor) => cursor && cursor.primaryKey[1]);\n        const [minStateKey, maxStateKey] = await Promise.all(\n            [minStateKeyProm, maxStateKeyProm]);\n\n        const writeTx = this.db.transaction(\n            [\"oob_membership_events\"],\n            \"readwrite\");\n        const writeStore = writeTx.objectStore(\"oob_membership_events\");\n        const membersKeyRange = IDBKeyRange.bound(\n            [roomId, minStateKey],\n            [roomId, maxStateKey],\n        );\n\n        logger.log(`LL: Deleting all users + marker in storage for room ${roomId}, with key range:`,\n            [roomId, minStateKey], [roomId, maxStateKey]);\n        await reqAsPromise(writeStore.delete(membersKeyRange));\n    }\n\n    /**\n     * Clear the entire database. This should be used when logging out of a client\n     * to prevent mixing data between accounts.\n     * @return {Promise} Resolved when the database is cleared.\n     */\n    public clearDatabase(): Promise<void> {\n        return new Promise((resolve) => {\n            logger.log(`Removing indexeddb instance: ${this.dbName}`);\n            const req = this.indexedDB.deleteDatabase(this.dbName);\n\n            req.onblocked = () => {\n                logger.log(`can't yet delete indexeddb ${this.dbName} because it is open elsewhere`);\n            };\n\n            req.onerror = () => {\n                // in firefox, with indexedDB disabled, this fails with a\n                // DOMError. We treat this as non-fatal, so that we can still\n                // use the app.\n                logger.warn(`unable to delete js-sdk store indexeddb: ${req.error}`);\n                resolve();\n            };\n\n            req.onsuccess = () => {\n                logger.log(`Removed indexeddb instance: ${this.dbName}`);\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * @param {boolean=} copy If false, the data returned is from internal\n     * buffers and must not be mutated. Otherwise, a copy is made before\n     * returning such that the data can be safely mutated. Default: true.\n     *\n     * @return {Promise} Resolves with a sync response to restore the\n     * client state to where it was at the last save, or null if there\n     * is no saved sync data.\n     */\n    public getSavedSync(copy = true): Promise<ISavedSync> {\n        const data = this.syncAccumulator.getJSON();\n        if (!data.nextBatch) return Promise.resolve(null);\n        if (copy) {\n            // We must deep copy the stored data so that the /sync processing code doesn't\n            // corrupt the internal state of the sync accumulator (it adds non-clonable keys)\n            return Promise.resolve(utils.deepCopy(data));\n        } else {\n            return Promise.resolve(data);\n        }\n    }\n\n    public getNextBatchToken(): Promise<string> {\n        return Promise.resolve(this.syncAccumulator.getNextBatchToken());\n    }\n\n    public setSyncData(syncData: ISyncResponse): Promise<void> {\n        return Promise.resolve().then(() => {\n            this.syncAccumulator.accumulate(syncData);\n        });\n    }\n\n    public async syncToDatabase(userTuples: UserTuple[]): Promise<void> {\n        if (this.isPersisting) {\n            logger.warn(\"Skipping syncToDatabase() as persist already in flight\");\n            this.pendingUserPresenceData.push(...userTuples);\n            return;\n        } else {\n            userTuples.unshift(...this.pendingUserPresenceData);\n            this.isPersisting = true;\n        }\n\n        try {\n            const syncData = this.syncAccumulator.getJSON(true);\n\n            await Promise.all([\n                this.persistUserPresenceEvents(userTuples),\n                this.persistAccountData(syncData.accountData),\n                this.persistSyncData(syncData.nextBatch, syncData.roomsData),\n            ]);\n        } finally {\n            this.isPersisting = false;\n        }\n    }\n\n    /**\n     * Persist rooms /sync data along with the next batch token.\n     * @param {string} nextBatch The next_batch /sync value.\n     * @param {Object} roomsData The 'rooms' /sync data from a SyncAccumulator\n     * @return {Promise} Resolves if the data was persisted.\n     */\n    private persistSyncData(\n        nextBatch: string,\n        roomsData: ISyncResponse[\"rooms\"],\n    ): Promise<void> {\n        logger.log(\"Persisting sync data up to\", nextBatch);\n        return utils.promiseTry<void>(() => {\n            const txn = this.db.transaction([\"sync\"], \"readwrite\");\n            const store = txn.objectStore(\"sync\");\n            store.put({\n                clobber: \"-\", // constant key so will always clobber\n                nextBatch,\n                roomsData,\n            }); // put == UPSERT\n            return txnAsPromise(txn).then(() => {\n                logger.log(\"Persisted sync data up to\", nextBatch);\n            });\n        });\n    }\n\n    /**\n     * Persist a list of account data events. Events with the same 'type' will\n     * be replaced.\n     * @param {Object[]} accountData An array of raw user-scoped account data events\n     * @return {Promise} Resolves if the events were persisted.\n     */\n    private persistAccountData(accountData: IMinimalEvent[]): Promise<void> {\n        return utils.promiseTry<void>(() => {\n            const txn = this.db.transaction([\"accountData\"], \"readwrite\");\n            const store = txn.objectStore(\"accountData\");\n            for (let i = 0; i < accountData.length; i++) {\n                store.put(accountData[i]); // put == UPSERT\n            }\n            return txnAsPromise(txn).then();\n        });\n    }\n\n    /**\n     * Persist a list of [user id, presence event] they are for.\n     * Users with the same 'userId' will be replaced.\n     * Presence events should be the event in its raw form (not the Event\n     * object)\n     * @param {Object[]} tuples An array of [userid, event] tuples\n     * @return {Promise} Resolves if the users were persisted.\n     */\n    private persistUserPresenceEvents(tuples: UserTuple[]): Promise<void> {\n        return utils.promiseTry<void>(() => {\n            const txn = this.db.transaction([\"users\"], \"readwrite\");\n            const store = txn.objectStore(\"users\");\n            for (const tuple of tuples) {\n                store.put({\n                    userId: tuple[0],\n                    event: tuple[1],\n                }); // put == UPSERT\n            }\n            return txnAsPromise(txn).then();\n        });\n    }\n\n    /**\n     * Load all user presence events from the database. This is not cached.\n     * FIXME: It would probably be more sensible to store the events in the\n     * sync.\n     * @return {Promise<Object[]>} A list of presence events in their raw form.\n     */\n    public getUserPresenceEvents(): Promise<UserTuple[]> {\n        return utils.promiseTry<UserTuple[]>(() => {\n            const txn = this.db.transaction([\"users\"], \"readonly\");\n            const store = txn.objectStore(\"users\");\n            return selectQuery(store, undefined, (cursor) => {\n                return [cursor.value.userId, cursor.value.event];\n            });\n        });\n    }\n\n    /**\n     * Load all the account data events from the database. This is not cached.\n     * @return {Promise<Object[]>} A list of raw global account events.\n     */\n    private loadAccountData(): Promise<IMinimalEvent[]> {\n        logger.log(`LocalIndexedDBStoreBackend: loading account data...`);\n        return utils.promiseTry<IMinimalEvent[]>(() => {\n            const txn = this.db.transaction([\"accountData\"], \"readonly\");\n            const store = txn.objectStore(\"accountData\");\n            return selectQuery(store, undefined, (cursor) => {\n                return cursor.value;\n            }).then((result: IMinimalEvent[]) => {\n                logger.log(`LocalIndexedDBStoreBackend: loaded account data`);\n                return result;\n            });\n        });\n    }\n\n    /**\n     * Load the sync data from the database.\n     * @return {Promise<Object>} An object with \"roomsData\" and \"nextBatch\" keys.\n     */\n    private loadSyncData(): Promise<ISyncData> {\n        logger.log(`LocalIndexedDBStoreBackend: loading sync data...`);\n        return utils.promiseTry<ISyncData>(() => {\n            const txn = this.db.transaction([\"sync\"], \"readonly\");\n            const store = txn.objectStore(\"sync\");\n            return selectQuery(store, undefined, (cursor) => {\n                return cursor.value;\n            }).then((results: ISyncData[]) => {\n                logger.log(`LocalIndexedDBStoreBackend: loaded sync data`);\n                if (results.length > 1) {\n                    logger.warn(\"loadSyncData: More than 1 sync row found.\");\n                }\n                return results.length > 0 ? results[0] : {} as ISyncData;\n            });\n        });\n    }\n\n    public getClientOptions(): Promise<IStartClientOpts> {\n        return Promise.resolve().then(() => {\n            const txn = this.db.transaction([\"client_options\"], \"readonly\");\n            const store = txn.objectStore(\"client_options\");\n            return selectQuery(store, undefined, (cursor) => {\n                return cursor.value?.options;\n            }).then((results) => results[0]);\n        });\n    }\n\n    public async storeClientOptions(options: IStartClientOpts): Promise<void> {\n        const txn = this.db.transaction([\"client_options\"], \"readwrite\");\n        const store = txn.objectStore(\"client_options\");\n        store.put({\n            clobber: \"-\", // constant key so will always clobber\n            options: options,\n        }); // put == UPSERT\n        await txnAsPromise(txn);\n    }\n\n    public async saveToDeviceBatches(batches: ToDeviceBatchWithTxnId[]): Promise<void> {\n        const txn = this.db.transaction([\"to_device_queue\"], \"readwrite\");\n        const store = txn.objectStore(\"to_device_queue\");\n        for (const batch of batches) {\n            store.add(batch);\n        }\n        await txnAsPromise(txn);\n    }\n\n    public async getOldestToDeviceBatch(): Promise<IndexedToDeviceBatch | null> {\n        const txn = this.db.transaction([\"to_device_queue\"], \"readonly\");\n        const store = txn.objectStore(\"to_device_queue\");\n        const cursor = await reqAsCursorPromise(store.openCursor());\n        if (!cursor) return null;\n\n        const resultBatch = cursor.value as ToDeviceBatchWithTxnId;\n\n        return {\n            id: cursor.key as number,\n            txnId: resultBatch.txnId,\n            eventType: resultBatch.eventType,\n            batch: resultBatch.batch,\n        };\n    }\n\n    public async removeToDeviceBatch(id: number): Promise<void> {\n        const txn = this.db.transaction([\"to_device_queue\"], \"readwrite\");\n        const store = txn.objectStore(\"to_device_queue\");\n        store.delete(id);\n        await txnAsPromise(txn);\n    }\n}\n"],"mappings":"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"}